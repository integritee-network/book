<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Integritee Book</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="introduction.html">Introduction</a></li><li class="expanded "><a href="trusted_execution.html"><strong aria-hidden="true">1.</strong> What is Trusted Execution?</a></li><li><ol class="section"><li class="expanded "><a href="remote_attestation.html"><strong aria-hidden="true">1.1.</strong> Remote Attestation</a></li></ol></li><li class="expanded "><a href="what_for.html"><strong aria-hidden="true">2.</strong> What is Integritee Good For?</a></li><li><ol class="section"><li class="expanded "><a href="privacy.html"><strong aria-hidden="true">2.1.</strong> Privacy</a></li><li class="expanded "><a href="scalability.html"><strong aria-hidden="true">2.2.</strong> Scalability</a></li><li class="expanded "><a href="interoperability.html"><strong aria-hidden="true">2.3.</strong> Interoperability</a></li><li><ol class="section"><li class="expanded "><a href="interoperability-bridges.html"><strong aria-hidden="true">2.3.1.</strong> Bridges</a></li></ol></li><li class="expanded "><a href="use_case_cdn.html"><strong aria-hidden="true">2.4.</strong> CDN</a></li></ol></li><li class="expanded "><a href="design.html"><strong aria-hidden="true">3.</strong> Design</a></li><li><ol class="section"><li class="expanded "><a href="sharding.html"><strong aria-hidden="true">3.1.</strong> Sharding</a></li><li class="expanded "><a href="token_shielding.html"><strong aria-hidden="true">3.2.</strong> Token Shielding</a></li><li class="expanded "><a href="security.html"><strong aria-hidden="true">3.3.</strong> Security</a></li><li><ol class="section"><li class="expanded "><a href="security_intel_sgx.html"><strong aria-hidden="true">3.3.1.</strong> Intel SGX</a></li><li class="expanded "><a href="security_tm_chainrelay.html"><strong aria-hidden="true">3.3.2.</strong> Threat model ChainRelay</a></li></ol></li><li class="expanded "><a href="benchmarks.html"><strong aria-hidden="true">3.4.</strong> Benchmarks</a></li><li class="expanded "><a href="hw_diversification.html"><strong aria-hidden="true">3.5.</strong> HW Diversification</a></li><li><ol class="section"><li class="expanded "><a href="hw_ra_by_distributor.html"><strong aria-hidden="true">3.5.1.</strong> Distributor-Level Remote Attestation</a></li></ol></li><li class="expanded "><a href="sidechain.html"><strong aria-hidden="true">3.6.</strong> Sidechain</a></li><li><ol class="section"><li class="expanded "><a href="sidechain_system_networking.html"><strong aria-hidden="true">3.6.1.</strong> System and Networking</a></li></ol></li></ol></li><li class="expanded "><a href="howto.html"><strong aria-hidden="true">4.</strong> Howto</a></li><li><ol class="section"><li class="expanded "><a href="howto_node.html"><strong aria-hidden="true">4.1.</strong> How To Run a Node</a></li><li class="expanded "><a href="howto_worker.html"><strong aria-hidden="true">4.2.</strong> How To Run a Worker</a></li><li class="expanded "><a href="howto_private_tx.html"><strong aria-hidden="true">4.3.</strong> How To Perform a Private Transaction</a></li><li class="expanded "><a href="howto_direct_tx.html"><strong aria-hidden="true">4.4.</strong> How To Perform Direct Invocation</a></li><li class="expanded "><a href="howto_sidechain_multivalidateer.html"><strong aria-hidden="true">4.5.</strong> How To Run a sidechain multi-validateer setup</a></li><li class="expanded "><a href="howto_access_onchain_storage.html"><strong aria-hidden="true">4.6.</strong> How To Access On-Chain Storage Trustlessly</a></li><li class="expanded "><a href="howto_stf.html"><strong aria-hidden="true">4.7.</strong> How To Build Your Own Trusted STF</a></li></ol></li><li class="expanded "><a href="roadmap.html"><strong aria-hidden="true">5.</strong> Roadmap</a></li><li class="expanded "><a href="glossary.html"><strong aria-hidden="true">6.</strong> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Integritee Book</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p align="center"><img src="./fig/integritee-logo.svg" height="300"/></p>
<p>Integritee is a framework for <a href="https://docs.substrate.dev/">Parity Substrate</a>, allowing to call a custom state transition function (STF) inside a Trusted Execution Environment (TEE), namely an Intel SGX enclave thereby providing confidentiality and integrity. The enclaves operate on an encrypted state which can be read and written only by a set of provisioned and remote-attested enclaves.</p>
<p>What Integritee aims to enable:</p>
<ul>
<li>confidential decentralized state transition functions
<ul>
<li>private transactions</li>
<li>private smart contracts</li>
<li>off-chain confidential personal data records (GDPR)</li>
<li>decentralized identity with selective disclosure</li>
<li>subscription-based content delivery networks</li>
</ul>
</li>
<li>scalability by providing a 2nd layer to substrate-based blockchains
<ul>
<li>off-chain smart contracts</li>
<li>payment hubs</li>
</ul>
</li>
<li>trusted chain bridges</li>
<li>trusted oracles</li>
</ul>
<p>Integritee is maintained by <a href="https://integritee.network">Integritee AG</a> and was originally developed by <a href="https://www.scs.ch">Supercomputing Systems AG</a> and has been supported by grants from the <a href="https://web3.foundation/">Web3 Foundation</a>.</p>
<p>We also thank the teams at</p>
<ul>
<li><a href="https://www.parity.io/">Parity Technologies</a> for building <a href="https://github.com/paritytech/substrate">substrate</a> and supporting us during development.</li>
<li><a href="https://github.com/apache/incubator-teaclave-sgx-sdk">Teaclave's Rust-SGX-SDK</a> for their very helpful support and contributions.</li>
</ul>
<p align="center"><img src="./fig/web3_foundation_grants_badge_black.svg" width="300" height="300"/></p>
<h1><a class="header" href="#trusted-execution" id="trusted-execution">Trusted Execution</a></h1>
<p>We have become accustomed to the fact that we have to trust our IT administrators. While these administrators used to be in-house employees at our companies, today we often work on rented cloud platforms.</p>
<p>These administrators can read and modify all the data processed on any machine they manage. Unfortunately, this ability extends not only to known administrators we trust but also to hackers who can obtain administrator privileges. No company, no matter how qualified, is immune to such attacks.</p>
<p>Enter TEEs.</p>
<p>You may envision a TEE as a co-processor that manages its own cryptographic keys. The manufacturer of the processor guarantees, by the design of their hardware, that nobody has access to the internal keys of the TEE or can read its memory. Moreover, the manufacturer can authenticate each TEE and provide remote attestation to a user to confirm that their untampered program is actually running on a genuine TEE, even if the machine is physically located in an off-site data center.</p>
<p>TEEs promise, in short, integrity and confidentiality of (remote) computation. You should be aware, however, of possible <a href="./security.html">security threats</a>.</p>
<p>Assuming we trust TEE manufacturers’ integrity and design competence, TEEs allow us to execute any state update without sharing our data with the blockchain validator or other users. Private token transfers, private smart contracts and private state channels thus become possible and relatively cheap.</p>
<h1><a class="header" href="#remote-attestation" id="remote-attestation">Remote Attestation</a></h1>
<p>TODO</p>
<p>The goal of attestation is to convince a third party that a specific piece of code is running on a genuine Intel SGX HW.</p>
<h2><a class="header" href="#convincing-the-integritee-user" id="convincing-the-integritee-user">convincing the Integritee user</a></h2>
<p>A user that interacts with Integritee wants to be sure that the shielding pubkey she uses to encrypt her call to the STF originates form an enclave that</p>
<ol>
<li>is running on genuine Intel SGX HW</li>
<li>runs the official code</li>
<li>accesses the correct STF state</li>
</ol>
<h3><a class="header" href="#classical-remote-attestation-solution" id="classical-remote-attestation-solution">Classical Remote Attestation Solution</a></h3>
<p>The standard use case for remote attestation involves a service provider (SP) like a video streaming service which wants to be sure his viewer application runs on a genuine SGX HW and respects DRM.
The SP therefore requests a quote from the application and sends that quote to Intel Attestation Services (IAS) who sign off the quote if it is genuine.</p>
<p>The issue here is that IAS only talks to registered clients. You need to register in order to get a SPID which needs to be supplied along with requests.</p>
<h3><a class="header" href="#attestation-registry-on-chain" id="attestation-registry-on-chain">Attestation Registry On-Chain</a></h3>
<p>It isn't practical to ask every client to register with Intel and perform RA before every request. Therefore we'd rather let the integritee-worker operators attest their enclaves with IAS and write the signed quote and their certificate to the blockchain for everyone to verify.</p>
<p>This does change the the attestation protocol. Now the SP and the enclave in the above scheme are both running on the same machine. integritee-worker will itself perform an attestation protocol with its enclave and get the quote signed by IAS. Like this, only Integritee operators need to register with IAS.</p>
<p><img src="./fig/attestation_registry_sequence.svg" alt="Sequence Diagram" /></p>
<p>The attestation report which is written to an on-chain registry contains:</p>
<ul>
<li>enclave quote
<ul>
<li>report body
<ul>
<li>MRENCLAVE (hash of enclave build)</li>
<li>Product ID (hard-coded in Integritee source)</li>
<li>Security Version (hard-coded in Integritee source)</li>
<li>user data is hash of context:
<ul>
<li>enclave-individual signing pubkey</li>
<li>latest block hash</li>
</ul>
</li>
</ul>
</li>
<li>...</li>
</ul>
</li>
<li>IAS response
<ul>
<li>body
<ul>
<li>status (OK||CONFIGURATION_NEEDED|GROUP_REVOKED....)</li>
<li>timestamp</li>
<li>enclave quote</li>
<li>...</li>
</ul>
</li>
<li>IAS certificate </li>
<li>IAS signature over above body</li>
</ul>
</li>
</ul>
<p>Any user can now verify IAS signature and MRENCLAVE (given the Integritee enclave can be built deterministically). See the <a href="https://github.com/rodolfoams/sgx-retrieve-identity/blob/5be913b96b2a6e5a0e1158ad169b977507291faa/Makefile#L253">example</a> how you can extract MRENCLAVE after building the enclave</p>
<p>The worker can now publish his sealing pubkey, signed with its enclave-individual signing key stated in the quote.</p>
<p>workers will repeat remote attestation in reasonable regular intervals (i.e. once per month)</p>
<h3><a class="header" href="#enclave-registry-on-chain" id="enclave-registry-on-chain">Enclave Registry On-Chain</a></h3>
<p>In order for the chain validator to be able to verify MRENCLAVE, there must be a consensus about MRENCLAVE of the valid version of Integritee.</p>
<p>Integritee developers will propose code updates to be voted on. Validators check the code and vote on behalf or against each proposal. MRENCLAVE can be reproduced by cloning the integritee-worker repo, building it and then:</p>
<pre><code class="language-bash">sgx_sign dump -enclave enclave.signed.so -dumpfile out.log
</code></pre>
<p>TODO: we might need to provide a docker environment the achieve deterministic builds.</p>
<h2><a class="header" href="#secret-provisioning" id="secret-provisioning">secret provisioning</a></h2>
<p>In order to establish shared secrets among workers, they need to convince themselves mutually that they are genuine before entering some <em>Distributed Key Generation</em> (DKG) protocol.</p>
<h2><a class="header" href="#sealing" id="sealing">Sealing</a></h2>
<p>provisioned secrets are sealed with Intel's <a href="https://software.intel.com/content/www/us/en/develop/blogs/introduction-to-intel-sgx-sealing.html">SGX Sealing</a>. Two different kinds of sealing exist. MRENCLAVE is unique for each build and each piece of HW. MRSIGNER is based on the authority of a SW vendor. The latter is practical for proprietary software because vendors can update their SW without re-provisioning secrets.</p>
<p>However, for decentralized open source projects, MRSIGNER cannot apply as there is no authority that could sign builds.</p>
<p>Therefore, <em>enclave identity</em> MRSIGNER must be applied.</p>
<h3><a class="header" href="#sw-updates" id="sw-updates">SW updates</a></h3>
<p>As SW updates will have a different measurement, the new build can't read the state that was encrypted by the old build. Local attestation allows the new version to request the provisioned secrets. </p>
<p>We assume reproducible builds for enclaves which should be possible with Rust subject to  some assumptions. For now, watch <a href="https://github.com/rust-lang/rust/issues/34902">this issue</a> and <a href="https://github.com/rust-secure-code/cargo-repro">cargo-repro</a>.</p>
<p>Simplified Protocol</p>
<ol>
<li>new version's TCB hash gets voted for by onchain consensus</li>
<li>new version registers its attestation on-chain</li>
<li>old version shares provisioned secret with new version running on same machine by means of local (intra-platform) attestation if new version's tcb corresponds to onchain registry</li>
</ol>
<p>See <a href="https://software.intel.com/content/www/us/en/develop/articles/innovative-technology-for-cpu-based-attestation-and-sealing.html">Intel's sealing paper</a></p>
<h2><a class="header" href="#ias" id="ias">IAS</a></h2>
<p>Intel <a href="https://software.intel.com/content/www/us/en/develop/blogs/intel-sgx-debug-production-prelease-whats-the-difference.html">defines different modes</a> for running enclaves.</p>
<p>compilation modes: <em>Debug</em>, <em>Release</em>, <em>Pre-Release</em>, <em>Simulation</em>
lanching modes: <em>Debug</em>, <em>Production</em></p>
<h3><a class="header" href="#epid" id="epid">EPID</a></h3>
<p>Enhanced Privacy ID (EPID). A group signature key known only to the quoting enclave. Only used for remote attestation.</p>
<h3><a class="header" href="#spid" id="spid">SPID</a></h3>
<p>A Service Provider ID (SPID) is needed to talk to IAS. Developers can obtain their SPID by <a href="https://api.portal.trustedservices.intel.com/EPID-attestation">registering with Intel</a> (only allows to attest DEBUG encalves!)</p>
<p>You can request either <em>linkable</em> or <em>unlinkable</em> quote. </p>
<p><strong>tl;dr</strong>: selecting UNLINKABLE is a safe choice. But don't expect to be anonymous.</p>
<p>In both cases, the quoting enclave uses a group signature for a quote. You can just decide if you wish two subsequent signatures to be linkable (an observer learns &quot;quote was signed by same platform&quot;) or not.</p>
<p>In any case, Intel can identify YOU by SSID as you use your SSID for remote attestation with IAS. It just doesn't learn about which HW platform the quote originates from.</p>
<h3><a class="header" href="#production-vs-debug-mode" id="production-vs-debug-mode">Production vs. Debug Mode</a></h3>
<p>Due to Intel policy, developers can only compile enclaves in <em>Debug</em>, <em>Pre-Release</em> or <em>Simulation</em> mode. This means that the enclave will always be launched in <em>Debug</em> mode which doesn't provide confidentiality as enclave memory isn't encrypted.</p>
<p>In order to compile enclaves in <em>Release</em> mode (and run them in <em>Production</em> mode), the SW vendor has to apply for a SGX production license. 
Moreover, remote attestation in production mode can only be taken out with such production license.</p>
<p><em>SCS is looking into options how to apply such policy to a decentralized system with Intel.</em></p>
<p><strong>solution candidate</strong></p>
<ol>
<li>A set of <em>companies</em> (i.e. SCS, web3 foundation) register a production license with Intel</li>
<li>integritee-workers send their RA quotes to the chain.</li>
<li>the <em>company</em> listens to new RA quotes and sends them to IAS with the <em>company's</em> SPID.</li>
<li>the <em>company</em> sends the IAS report to the chain.</li>
</ol>
<h2><a class="header" href="#literature" id="literature">Literature</a></h2>
<p>chaotic list of pointers:</p>
<ul>
<li><a href="https://davejingtian.org/2017/11/10/some-notes-on-the-monotonic-counter-in-intel-sgx-and-me/">review of SGX PSE for monotonic counters and trusted time</a></li>
</ul>
<h1><a class="header" href="#what-to-use-tees-for" id="what-to-use-tees-for">What to use TEEs for</a></h1>
<p>We list some original ideas here. Not all of them have been implemented already</p>
<h2><a class="header" href="#different-ways-to-leverage-tees" id="different-ways-to-leverage-tees">Different ways to leverage TEEs</a></h2>
<table><thead><tr><th>use case</th><th>integritee-signer <br>(off-chain stateless)</th><th>integritee-worker<br> (off-chain stateful)</th><th>integritee-node<br> (onchain-stateful)</th></tr></thead><tbody>
<tr><td>hardware wallet</td><td>:+1: local TEE per user</td><td></td><td>:thumbsdown:</td></tr>
<tr><td>atomic swaps<br>(cross-chain bridge)</td><td>:+1: light node in both chains</td><td>:+1:</td><td>:thumbsdown:</td></tr>
<tr><td>coinmixer</td><td>:+1:</td><td>:thumbsdown:</td><td>:thumbsdown:</td></tr>
<tr><td>oracle</td><td>:+1:</td><td>:+1:</td><td>difficult if non-deterministic</td></tr>
<tr><td>inheritance notary</td><td>:+1:</td><td>:+1:</td><td>storage expensive</td></tr>
<tr><td>confidential transactions</td><td>:thumbsdown:</td><td>:thumbsdown: doesn't scale? (collisions of state changes)</td><td>:+1: <a href="https://encointer.org">encointer</a></td></tr>
<tr><td>2nd layer confidential payment hub (Similar to <a href="https://github.com/lsds/Teechain">TeeChan</a>)</td><td></td><td>:+1:</td><td></td></tr>
<tr><td>confidential smart contracts</td><td>:thumbsdown:</td><td>:+1: (Ekiden, PDO, <a href="https://encointer.org">encointer</a>)</td><td>computation time and storage expensive</td></tr>
<tr><td><a href="https://sawtooth.hyperledger.org/docs/core/releases/1.0/architecture/poet.html">POET</a> consensus</td><td>:thumbsdown:</td><td>:thumbsdown:</td><td>:thumbsdown:</td></tr>
</tbody></table>
<h2><a class="header" href="#integritee-signer" id="integritee-signer">integritee-signer</a></h2>
<p><em>off-chain</em>: nothing special needs to be run by blockchain validators. normal transactions</p>
<p><em>stateless</em>: no state needs to be preserved (onchain - data or hash) between uses</p>
<p><img src="fig/integritee-signer.svg" alt="signer" /></p>
<p>One flavour of Integritee is a RPC client for substrate that runs a state transition function (STF) within a TEE (Intel SGX).</p>
<p>Main feature: trusted hardware custodian of your private keys</p>
<h2><a class="header" href="#integritee-worker" id="integritee-worker">integritee worker</a></h2>
<p><em>off-chain</em>: nothing special needs to be run by blockchain validators. normal transactions</p>
<p><em>stateful</em>: state needs to be preserved (onchain - data or hash) between uses</p>
<p><img src="fig/integritee-offchain-contract.svg" alt="offchain-contract" /></p>
<p>Similar to but still quite different than <a href="https://github.com/hyperledger-labs/private-data-objects">sawtooth PDO</a> or <a href="https://www.oasislabs.com/">Ekiden/OasisLabs</a></p>
<p><em>Do not confuse integritee-worker with substrate's <a href="https://github.com/paritytech/substrate/pull/1942">off-chain workers</a>. The latter are a part of the node's codebase. integritee-worker is a standalone service interfacing substrate node using RPC or websockets</em></p>
<p>Dapps can commit WASM contracts and run their own TEE's or hire an enclave service to run confidential WASM smart contracts on. delegates are remote attested on the blockchain (the TCB doesn't include the WASM contract). They have to be fed with the most recent state, call and opaque payload. They then update the state that is written back to the chain.</p>
<h2><a class="header" href="#integritee-stealth-node" id="integritee-stealth-node">integritee-stealth-node</a></h2>
<p><em>on-chain</em>: blockchain validators run confidential state transition function with every extrinsic.</p>
<p><em>stateful</em>: state needs to be preserved (onchain - data or hash) between uses</p>
<p>a fork of substrate that has an Executor running in a TEE (Intel SGX)</p>
<p>Main feature: many confidential transactions can be executed with every block</p>
<p><img src="fig/integritee-stealth-node.svg" alt="node" /></p>
<h1><a class="header" href="#privacy" id="privacy">Privacy</a></h1>
<p>Integritee leverages the confidentiality guarantees of TEEs, namely Intel SGX.</p>
<p>Whatever is computed inside Integritee worker enclaves can't be observed by the network nor by the operator of the worker service nor by the root user nor a cloud provider admin.</p>
<p>What Integritee can't provide is network layer privacy. That's what <a href="https://www.torproject.org/">Tor</a> or <a href="https://nymtech.net">Nym</a> are for.</p>
<h1><a class="header" href="#scalability" id="scalability">Scalability</a></h1>
<p>Integritee with <a href="./design.html#direct-invocation-vision">direct invocation</a> is a 2nd layer technology: It allows to do state transitions without the individual transactions hitting the blockchain.</p>
<ul>
<li>more transactions per second because no global consensus must be reached on individual transactions (we trust the TEEs integrity)</li>
<li>less latency because there's no need to wait for block inclusion</li>
<li>disk usage and load balancing can be scaled horizontally: Integritee also features <a href="./sharding.html">sharding</a></li>
</ul>
<h1><a class="header" href="#interoperability" id="interoperability">Interoperability</a></h1>
<p>Chain interoperability is considered one of the more pressing challenges for blockchain technology. With <a href="https://github.com/integritee-network/substraTEE">substraTEE</a>, we've built a tool that is well suited to solve trusted chain bridges, because the integrity of code execution is guaranteed by a TEE.</p>
<p>See our proposal for <a href="./interoperability-bridges.html">PolkaETH bridge</a></p>
<h1><a class="header" href="#bridges" id="bridges">Bridges</a></h1>
<p><img src="fig/integritee-bridge-overview.svg" alt="PolkaETH" /></p>
<h2><a class="header" href="#example-concept-for-polkaeth-bridge" id="example-concept-for-polkaeth-bridge">Example Concept for PolkaETH Bridge</a></h2>
<p>integritee-bridge will allow to:</p>
<ul>
<li>transfer ETH to a pegged token on substrate and back (PolkaETH).</li>
<li>transfer ERC-20 token on Ethereum to a pegged token on substrate and back (PolkaXYZ).</li>
<li>transfer any on-chain information between Ethereum and substrate.</li>
<li>transfer any token on Polkadot to an Ethereum ERC20 token.</li>
</ul>
<p>integritee-bridge will build light clients of both chains. Block headers are stored in SGX sealed storage and transaction inclusion proofs are verified in Intel SGX enclaves. Backed value will be in custody of a set of TEEs. Correct execution is guaranteed by TEEs (Intel SGX).</p>
<p>In contrast to an approach like <a href="https://www.xclaim.io/">XClaim</a>, integritee-bridge provides the following advantages:</p>
<ul>
<li>No over-collateralization required for the bridge operator. XClaim needs vaults (or <em>banks</em>) with more value locked as collateral than is transferred through the bridge in order to punish misbehaving bridge operators. Because of the opportunity cost of locked capital, this would lead to higher fees for using such a bridge. In integritee-bridge, SGX guarantees integrity of computation and thus also the brigde operator. Therefore, there is no need for over-collateralization.</li>
<li>No relay-contract with on-chain registry of block headers needed. Block headers are stored in the enclave's sealed storage. Less onchain storage is needed on the issuing chain.</li>
<li>Less transactions needed as there is no need for a collateralized issue commitment.</li>
</ul>
<p>The term <em><strong>light client</strong></em> is used ambiguously in the scene. We use the following definition of light client:</p>
<blockquote>
<p>a light client can be viewed as a client that downloads block headers by default, and verifies only a small portion of what needs to be verified, using a distributed hash table as a database for trie nodes in place of its local hard drive
(<a href="https://github.com/ethereum/wiki/wiki/Light-client-protocol">source</a>)</p>
</blockquote>
<h3><a class="header" href="#technical-concept" id="technical-concept">Technical Concept</a></h3>
<p>With regard to the document <a href="https://hackmd.io/UVzp6Z-bRAOo9Ny531yhmA">Polkadot Bridges: Design Considerations for bridging to PoW chains</a> as well as the <a href="https://www.xclaim.io/">XClaim Paper</a>, we intend to implement the <em>CentralClaim</em> Protocol with a single SGX instance as a first step (Protocols: <em>Issue</em> and <em>Redeem</em>. <em>Transfer</em> and <em>Swap</em> are off-topic). Because we leverage SGX, our CentralClaim already achieves <em>Consistency</em>, as there is no way to fraudulently issue PolkaETH without breaking SGX guarantees.</p>
<p>As pointed out in XClaim, the CentralClaim protocol doesn't achieve <em>Redeemability</em> nor <em>Liveness</em>. In contrast to Xclaim we don't suggest a punishment scheme for fraudulent vaults as they have no economic incentive to misbehave in our scheme. Instead, we implement a shared custody of locked backing chain tokens (ETH) among a set of integritee-bridge enclaves. The set of integritee-bridge instances is unpermissioned, so anyone with suitable HW can register as a integritee-bridge along the design of <a href="https://github.com/integritee-network/substraTEE">substraTEE</a>. A threshold signature scheme is applied in order to supply <em>Redeemability</em> and <em>Liveness</em>.</p>
<p>The set of active integritee-bridge instances changes over time. Some instances will go offline, others will join. The multisig wallets will have to be updated with every mutation. One approach with improved forward security would be to generate new multisig wallets with every mutation (instead of updating members). This way TEE's that do not update their SGX platform with the most recent patches will lose access to funds as they will be rejected by the remote attestation process and therefore not be included in the new multisig set.</p>
<p>We also need to guarantee <em>all-or-nothing fairness</em> (tx1 on the backing chain and tx2 on the issuing chain are either both included or both rejected). By using a TEE, we can make sure that bridges will correctly generate tx2 upon being shown a proof of inclusion for tx1. However, we can't guarantee that tx2 is included in the other chain by relying on a single TEE as the operator could prevent tx2 from being sent to the network among other attacks.
If users have many integritee-bridge operators to chose from, we rely on the fact that these operators have an economic incentive to follow the protocol: They can't access locked funds but they can collect fees. We only need M-of-N (configurable threshold) of these operators to play fair in order to guarantee <em>all-or-nothing fairness</em>.</p>
<p>Further hardening (including time locked transactions) is described in the <a href="https://eprint.iacr.org/2017/1153.pdf">Tesseract Paper</a> and is left for future work if security audits require it.</p>
<h4><a class="header" href="#reference-light-client-implementations" id="reference-light-client-implementations">Reference Light Client Implementations</a></h4>
<p>Substrate as well as Ethereum clients geth and parity come with the option to run as light clients (i.e. <code>parity --light</code>). We suggest to port ethereum parity's and substrate's light clients' validation logic into SGX enclaves. While the networking can be conventional untrusted code, the tracking of block headers as well as the validation of Merkle proofs need to be performed in SGX enclaves, so the bridge operator can convince others (the receiving chain) of the validity of a statement.</p>
<h4><a class="header" href="#risks" id="risks">Risks</a></h4>
<p>Vulnerabilities in SGX may lead to total loss of locked funds as well as infinite issuance of unredeemable PolkaETH. This risk is mitigated by our M-of-N threshold signature scheme. At least M enclaves must be compromised in order to do any harm.</p>
<p>If remote attestation is compromised as well, fake enclaves can join the set of integritee-bridges and outnumber the existing set of bridges.</p>
<h3><a class="header" href="#related-work" id="related-work">Related Work</a></h3>
<h4><a class="header" href="#parity-bridge" id="parity-bridge">parity-bridge</a></h4>
<p><a href="https://github.com/paritytech/parity-bridge">Parity bridge</a> allows an Ethereum PoA chain to bridge to the Ethereum Mainnet using <a href="https://github.com/parity-contracts/bridge/blob/master/contracts/bridge.sol">contracts</a> on both chains. The bridge is generic (arbitrary information can be passed) and bidirectional. Trust in the PoA chain validators is required.</p>
<p>integritee-bridge would replace this trust in PoA validators by trust in a single TEE or a set of TEE's (Intel SGX).</p>
<h4><a class="header" href="#xclaim" id="xclaim">XClaim</a></h4>
<p><a href="https://www.xclaim.io/">XClaim</a> solves the bridge problem not by trusting PoA validators but by incentivized and punishable actors. However, this approach demands over-collateralization and is therefore economically less attractive at scale than integritee-bridge.</p>
<h4><a class="header" href="#tesseract" id="tesseract">Tesseract</a></h4>
<p>The <a href="https://eprint.iacr.org/2017/1153.pdf">Tesseract Paper</a> describes a trusted cryptocurrency exchange design using Intel SGX. In section 7 they describe a bridge protocol.</p>
<h1><a class="header" href="#use-case-cdn-subscriptions" id="use-case-cdn-subscriptions">Use Case CDN Subscriptions</a></h1>
<p>Integritee could be used to restrict (narrow- or broadband) content delivery to paying users. Examples could be blogs, articles, video streaming, video on-demand, music streaming or on-deman aso.</p>
<h2><a class="header" href="#basic-integritee-application-for-cdn" id="basic-integritee-application-for-cdn">Basic Integritee application for CDN</a></h2>
<ul>
<li>Subscriptions are managed on-chain, as are payments (can be flat subscription fees or pay-per-use)</li>
<li>integrite-worker holds the content-encryption key pair (CEK). Only the worker enclave(s) can read this RSA private key.
No consumers or publishers nor operators have access</li>
<li>publishers commit their content (encrypted with the CEK (RSA+AES)) to IPFS and register the content on-chain, providing the IPFS url</li>
<li>consumers request content from the integritee-worker over a TLS channel (can be https, wss, json-rpc, REST), which
<ul>
<li>authenticates the consumer and looks up subscription status on-chain</li>
<li>fetches the requested content from IPFS</li>
<li>decrypts the content</li>
<li>sends the content to the consumer over the previously established TLS channel</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#cek-turnover" id="cek-turnover">CEK turnover</a></h2>
<p>As a first implementation, the CEK can stay constant over time. However, we should be able to rotate this key if we need to revoke.</p>
<h2><a class="header" href="#access-to-archive-prior-to-subscription" id="access-to-archive-prior-to-subscription">Access to Archive Prior to Subscription</a></h2>
<p>Because the private CEK is known to all worker enclaves and never needs to be known to publishers or subscribers we do not need to trans-encrypt content.
It doesn't matter at what time a consumer subscribes. The worker can deliver all prior content to the subscriber.
The subscription metadata can include restrictions to archive access.</p>
<h2><a class="header" href="#pay-per-use" id="pay-per-use">Pay per use</a></h2>
<p>Pay per use bears the risks of leaking private information. We'd suggest to maintain subscription balances within the worker enclave, not onchain. This way, the public doesn't learn detailed usage patterns. See our <a href="./howto_private_tx.html">private-tx example</a> for how this could work.</p>
<h1><a class="header" href="#design" id="design">Design</a></h1>
<p>In the following we explain how Integritee works and how the different components play together.</p>
<h2><a class="header" href="#direct-invocation-vision" id="direct-invocation-vision">Direct Invocation (Vision)</a></h2>
<p><img src="./fig/substraTEE-vision.png" alt="vision" />
<em>Integritee Target Architecture with Direct Invocation (future scenario)</em></p>
<ul>
<li>Shielding key: used by the integritee-client to encrypt the call in order to protect caller privacy. It is common to all enclaves.</li>
<li>State encryption key: used to encrypt and decrypt the state storage. It is common to all enclaves.</li>
<li>Signing key: used to sign transactions for the integritee-node. The corresponding account must be funded in order to pay for chain fees. It is unique for every enclave.</li>
</ul>
<h3><a class="header" href="#how-it-works" id="how-it-works">How it works</a></h3>
<p>The <em>integritee-node</em> is a substrate blockchain node with an additional runtime module:</p>
<ul>
<li>integritee-registry module: proxies requests to workers, verifies IAS reports and keeps track of the registered enclaves. It provides the following API interfaces:
<ul>
<li>Register an enclave</li>
<li>Remove an enclave</li>
<li>Get the list of enclaves</li>
<li>invoke worker</li>
<li>confirm processing of requests</li>
</ul>
</li>
</ul>
<p>The <em>integritee-worker</em> checks on the first start-up if &quot;his&quot; enclave is already registered on the chain. If this is not the case, it requests a remote attestion from the Intel Attestation Service (IAS) and sends the report to the <em>teerex module</em> to register his enclave.</p>
<p>If there is already an enclave (belonging to a different integritee-worker) registered on the chain, the integritee-worker requests provisioning of secrets (the <em>shielding and state encryption private key</em>) from the already registered enclave. The exchange of critical information between the enclaves is performed over a secure connection (TLS). The two enclaves perform a mutual remote attestation before exchanging any secrets.</p>
<h2><a class="header" href="#indirect-invocation-current-implementation" id="indirect-invocation-current-implementation">Indirect Invocation (current implementation)</a></h2>
<p>The high level architecture of the current implementation can be seen in the following diagram:</p>
<p><img src="fig/integritee-worker-overview.svg" alt="Diagram" /></p>
<p>The main building blocks can be found in the following repositories:</p>
<ul>
<li><a href="https://github.com/integritee-network/integritee-node">integritee-node</a>: (custom substrate node) A substrate node with a custom runtime module</li>
<li><a href="https://github.com/integritee-network/worker">integritee-worker</a>: (client, worker-app, worker-enclave): A SGX-enabled service that performs a confidential state-transition-function</li>
</ul>
<h3><a class="header" href="#request-lifetime-end-to-end" id="request-lifetime-end-to-end">Request Lifetime end-to-end</a></h3>
<p><img src="fig/integritee_request_format_end2end.svg" alt="request-end-to-end" /></p>
<h2><a class="header" href="#redundancy-m3-onwards" id="redundancy-m3-onwards">Redundancy (M3 onwards)</a></h2>
<p>The goal of redundancy is to allow multiple workers to operate on the same state to be resilient against outage of one or more workers.</p>
<p>The high level architecture for M3 and M4 can be seen in the following diagram:</p>
<p><img src="fig/integritee-architecture-M4.svg" alt="Diagram" /></p>
<p>where M3 includes only the <em>docker image 1</em> and the <em>Intel Attestation Service (IAS)</em> and M4 includes the three <em>docker images</em> and the <em>Intel Attestation Service (IAS)</em>.</p>
<h1><a class="header" href="#sharding" id="sharding">Sharding</a></h1>
<p>Integritee isolates confidential state from the blockchain by maintaining it off-chain and processing it in TEEs. This strategy allows application-specific sharding. Every use case can work on its own shard and even one use case could split into several shards.</p>
<p>By default, Integritee uses the MRENCLAVE of the worker enclave as shard identifier, so in most cases, your shard is directly linked to your specific TCB and there's nothing you have to worry about.</p>
<p>If you want to use your TCB for more than one use case, you might want to split into shards.</p>
<p><img src="./fig/SGX-TCB-shard-overview.svg" alt="Sharding UML" /></p>
<p>A single SGX HW can run many worker instances, all operating on different shards (and possibly even different TCBs).</p>
<h1><a class="header" href="#token-shielding" id="token-shielding">Token Shielding</a></h1>
<p>Token shielding is the process of transferring on-chain tokens (where they are transferred transparently) to off-chain STF (where transactions are private). The on-chain tokens are kept in enclave custody on a bonding account until unshielded again.</p>
<p>Unshielding is the reverse process, where off-chain funds are transferred to on-chain accounts. The bonding account then releases these funds on behalf of the owner's public account.</p>
<p><img src="./fig/shielding-unshielding-sequence-diagram.svg" alt="Sharding UML" /></p>
<h1><a class="header" href="#integritee-security" id="integritee-security">Integritee Security</a></h1>
<p>The following is an overview of security aspects of Integritee. It is neither complete nor guaranteed to be accurate. It just reflects the best of our knowledge ATM.</p>
<ul>
<li><a href="security_intel_sgx.html">Intel SGX security</a></li>
<li><a href="security_tm_chainrelay.html">Threat model of the ChainRelay</a></li>
</ul>
<h1><a class="header" href="#intel-sgx-security" id="intel-sgx-security">Intel SGX Security</a></h1>
<p>The following is an overview of security aspects of integritee, mainly focusing on Intel SGX properties. It is neither complete nor guaranteed to be accurate. It just reflects the best of our knowledge ATM.</p>
<h2><a class="header" href="#exploitable-properties-of-sgx" id="exploitable-properties-of-sgx">exploitable properties of SGX</a></h2>
<ul>
<li>An enclave has no way to control how many instances of that enclave are instantiated.</li>
<li>An enclave process can be interrupted at any point.</li>
<li>monotonic counter and trusted time provided by Platform Services (PSE) rely on Intel ME, which <a href="https://en.wikipedia.org/wiki/Intel_Management_Engine#Security_vulnerabilities">doesn't have a good reputation for security</a>.</li>
</ul>
<p>See: <a href="https://youtu.be/0ZxBO3vLB-A">black hat presentation by Swami</a></p>
<h2><a class="header" href="#attacks" id="attacks">Attacks</a></h2>
<h3><a class="header" href="#rollbackreplay-attack" id="rollbackreplay-attack">Rollback/Replay Attack</a></h3>
<p>An enclave has no way to verify that it is operating on the latest state (i.e. read from a sealed file on disk).</p>
<p>It cannot be assured that calls to the enclave happen sequentially. They can happen in parallel, possibly leaking secrets i.e. because a secret with weak randomness is encrypted many times with the same nonce, weakening the confidentiality.</p>
<h4><a class="header" href="#countermeasures" id="countermeasures">Countermeasures</a></h4>
<ul>
<li>monotonic counter (i.e. Intel PSE, based on ME. Not available on server HW). If you choose to trust Intel ME!</li>
<li>Blockchain registers the hash of the latest state, so a state update is only valid when it refers to the latest registered state. This doesn't solve the cause, but the symptoms.</li>
</ul>
<h3><a class="header" href="#global-state-malleability" id="global-state-malleability">Global State Malleability</a></h3>
<p>An enclave ecall can be interrupted at any time by interrupts. Instead of returning after the interrupt, an attacker can then call the same ecall again.</p>
<h4><a class="header" href="#countermeasures-1" id="countermeasures-1">Countermeasures</a></h4>
<ul>
<li>verify-first-write-last: not only for sealed storage, but also for global state variables.</li>
</ul>
<h3><a class="header" href="#reentrancy-attack--global-state-malleability" id="reentrancy-attack--global-state-malleability">Reentrancy Attack / Global state Malleability</a></h3>
<p>Can be a special case of the <em>Rollback Attack</em>.
Similar to smart contracts reentrancy.</p>
<p><a href="https://medium.com/@gus_tavo_guim/reentrancy-attack-on-smart-contracts-how-to-identify-the-exploitable-and-an-example-of-an-attack-4470a2d8dfe4">Explanation of reentrancy attack for smart contracts</a></p>
<h4><a class="header" href="#countermeasures-2" id="countermeasures-2">Countermeasures</a></h4>
<ul>
<li>verify-first-write-last</li>
</ul>
<h3><a class="header" href="#simulator-attacks" id="simulator-attacks">Simulator Attacks</a></h3>
<p>Some emulator pretends to be an enclave.</p>
<h4><a class="header" href="#countermeasure" id="countermeasure">Countermeasure</a></h4>
<ul>
<li>Remote Attestation with IAS</li>
</ul>
<h3><a class="header" href="#man-in-the-middle-attack" id="man-in-the-middle-attack">Man-In-The-Middle Attack</a></h3>
<p>Intel could attack a service provider by always replying to RA requests positively and put a simulated enclave as a MITM.
(Intel knows, which SP is requesting a RA as it knows the SPID)</p>
<h4><a class="header" href="#countermeasure-1" id="countermeasure-1">Countermeasure</a></h4>
<p>none.</p>
<p>See <a href="https://youtu.be/0ZxBO3vLB-A">black hat presentation by Swami</a> at 34:50</p>
<h3><a class="header" href="#foreshadow" id="foreshadow">Foreshadow</a></h3>
<p>This side-channel attack compromised both integrity and confidentiality (and therefore Remote Attestation as well). It has been fixed in Intel's recent microcode.</p>
<p><a href="https://en.wikipedia.org/wiki/Foreshadow_(security_vulnerability)">Foreshadow</a></p>
<h4><a class="header" href="#countermeasures-3" id="countermeasures-3">Countermeasures</a></h4>
<ul>
<li>update your SGX HW</li>
<li>verify SGX is up-to-date for all integritee-workers (IAS tells us with their remote attestation report)</li>
</ul>
<h1><a class="header" href="#threat-model-of-chainrelay" id="threat-model-of-chainrelay">Threat model of ChainRelay</a></h1>
<h2><a class="header" href="#introduction" id="introduction">Introduction</a></h2>
<p>A security threat model for the ChainRelay of Integritee.</p>
<p>The following points will be analysed:</p>
<ul>
<li><strong>S</strong>poofing</li>
<li><strong>T</strong>ampering</li>
<li><strong>R</strong>epudiation</li>
<li><strong>I</strong>nformation disclosure</li>
<li><strong>D</strong>enial of service</li>
<li><strong>E</strong>levation of privileges</li>
</ul>
<h2><a class="header" href="#system-overview" id="system-overview">System overview</a></h2>
<p><img src="fig/integritee-chainRelay-dataflow.svg" alt="Diagram" /></p>
<h2><a class="header" href="#actors" id="actors">Actors</a></h2>
<h3><a class="header" href="#user" id="user">User</a></h3>
<p>User of the system that holds tokens either on-chain or in an incognito account.</p>
<ul>
<li>He uses the integritee-cli</li>
<li>He can send extrinsics/transactions to the node that will then be processed by the enclave</li>
<li>He can query his own enclave state, the enclave public key and the mutual-remote-attestation port directly from a worker over WebSocket</li>
<li>He holds his key pairs (for on-chain and incognito accounts)</li>
</ul>
<h3><a class="header" href="#worker-operator" id="worker-operator">Worker operator</a></h3>
<p>Operates the worker and the enclave.</p>
<ul>
<li>He uses the integritee-service</li>
<li>He has full access to the system (HW, OS and services)</li>
</ul>
<h3><a class="header" href="#vendor" id="vendor">Vendor</a></h3>
<p>Releases Integritee software</p>
<ul>
<li>He distributes SW binaries</li>
<li>He can sign enclaves with MRSIGNER</li>
</ul>
<p>There is no specific vendor in Integritee as it is open source code that can be deterministically built by anyone to reach an identical MRENCLAVE for the enclave. Therefore, each operator is also a vendor!</p>
<p>Because of this Integritee may not use MRSIGNER policy but MRENCLAVE for SGX sealed storage (known issue https://github.com/integritee-network/worker/issues/88)! This means that sealed storage can only be accessed by the very same untampered version of the enclave running on the same HW platform.</p>
<p>Software updates are not yet supported: https://github.com/integritee-network/worker/issues/85</p>
<h2><a class="header" href="#analysis" id="analysis">Analysis</a></h2>
<table><thead><tr><th><strong>Attack Category</strong></th><th><strong>Actor</strong></th><th><strong>Description</strong></th><th><strong>Mitigation</strong></th><th><strong>Assessment</strong></th></tr></thead><tbody>
<tr><td>Impersonation</td><td>User</td><td>Get access to private keys of other users.</td><td>Protection of keys and key stores with passwords.<br/>WARNING: This is the responsibility of the developer building the client. Our example client does not include any mitigations.</td><td>delegated</td></tr>
<tr><td>Eclipsing</td><td>Operator or ISP</td><td>Expose the worker to a different (malicious) node</td><td>Rely on finality and read proofs with Light-Client</td><td>OK since M6</td></tr>
<tr><td>Spoofing</td><td>Operator</td><td>Modify the enclave to perform malicious operations</td><td>Remote Attestation, TrustedCall signature payload includes MRENCLAVE</td><td>OK</td></tr>
<tr><td>Tampering</td><td>User</td><td>Replay TrustedCalls (i.e. repeat transactions of funds until account depleted)</td><td>Use of nonce in TrustedCall</td><td><a href="https://github.com/integritee-network/worker/issues/89">known issue</a></td></tr>
<tr><td>Tampering</td><td>Operator</td><td>Tamper with the block header store of the Light-Client (roll back or modify)</td><td>Block header store is encrypted as SGX sealed storage<br/>Sync with chain upon startup<br/>Verify linked-hash-chain of block headers</td><td>OK</td></tr>
<tr><td>Tampering</td><td>Operator</td><td>Tamper with the state of the enclave</td><td>State is encrypted with the state-encryption-key, the private key stored in SGX sealed storage with MRENCLAVE policy</td><td><a href="https://github.com/integritee-network/worker/issues/88">known issue</a></td></tr>
<tr><td>Tampering</td><td>Operator</td><td>Block confirmations from worker to node</td><td>Redundancy of workers</td><td>OK</td></tr>
<tr><td>Tampering</td><td>Operator</td><td>Modify worker-api response to TrustedGetter</td><td>Enclave signs responses</td><td><a href="https://github.com/integritee-network/worker/issues/91">known issue</a></td></tr>
<tr><td>Repudiation</td><td>Operator</td><td>Deny WorkerApi access to certain users selectively</td><td>Redundancy of workers</td><td>OK</td></tr>
<tr><td>Information disclosure</td><td>Operator</td><td>Get information about contents of TrustedCalls</td><td>TrustedCalls are encrypted with public shielding key of the enclave (whose private key is stored in SGX sealed storage with MRENCLAVE policy)</td><td><a href="https://github.com/integritee-network/worker/issues/88">known issue</a></td></tr>
<tr><td>Information disclosure</td><td>Operator</td><td>Get information about contents of TrustedGetters responses</td><td>Encrypt responses<br/>wss:// to WorkerApi into enclave</td><td><a href="https://github.com/integritee-network/worker/issues/91">known issue</a></td></tr>
<tr><td>Information disclosure</td><td>Operator</td><td>Get meta information about TrustedCalls</td><td>Indirect invocation: need to use public account to proxy the TrustedCall through blockchain. Use fresh unlinkable accounts for each TrustedCall.<br/>Direct invocation: limited access to meta information (network layer only)</td><td>(delegated)<br/><a href="https://github.com/integritee-network/worker/issues/88">known issue</a></td></tr>
<tr><td>Information disclosure</td><td>Operator</td><td>Know which incognito account belongs to whom</td><td>SGX confidentiality guarantees, encrypted TrustedCall and TrustedGetter with enclave shielding key</td><td><a href="https://github.com/integritee-network/worker/issues/88">known issue</a></td></tr>
<tr><td>Information disclosure</td><td>Operator</td><td>Leak state information</td><td>SGX confidentiality guarantees, encrypted state with state-encryption-key<br/>MRENCLAVE policy for SGX sealed storage</td><td><a href="https://github.com/integritee-network/worker/issues/88">known issue</a></td></tr>
<tr><td>Information disclosure</td><td>User</td><td>Get information about other accounts and users in the enclave</td><td>Authentication of TrustedGetter.<br/>User can only query own state</td><td>OK</td></tr>
<tr><td>Denial of service</td><td>Operator</td><td>Limit the resources of the worker or the enclave to slow down the system</td><td>Redundancy of workers</td><td>OK</td></tr>
<tr><td>Denial of service</td><td>User</td><td>Send invalid transactions to crash either the worker or the enclave</td><td>Ensure enclave code doesn't panic</td><td>OK to the best of our knowledge</td></tr>
<tr><td>Denial of service</td><td>User</td><td>Overload the system with spam (TrustedGetters or TrustedCalls)</td><td>TrustedCalls: cost of tx fees (indirect invocation), block size limit<br/>TrustedGetter: load balancing as needed (scale number of workers horizontally), standard DDoS mitigation</td><td>delegated</td></tr>
</tbody></table>
<h1><a class="header" href="#benchmark" id="benchmark">Benchmark</a></h1>
<p><em>TODO</em> Outdated</p>
<table><thead><tr><th>ops</th><th>call_counter_wasm</th><th>call_counter</th><th>no compose_extrinsic</th><th>msg decryption</th><th>counter update</th><th>sgx_file_read</th><th>counter update + no_ops ocall</th></tr></thead><tbody>
<tr><td>ecall</td><td>☑</td><td>☑</td><td>☑</td><td>☑</td><td>☑</td><td>☑</td><td>☑</td></tr>
<tr><td>sgx::fs::read (rsa key)</td><td>☑</td><td>☑</td><td>☑</td><td>☑</td><td></td><td>☑</td><td>☑</td></tr>
<tr><td>rsa msg decryption</td><td>☑</td><td>☑</td><td>☑</td><td>☑</td><td></td><td></td><td>☑</td></tr>
<tr><td>wasm sha256 computation</td><td>☑</td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>wasm invokation</td><td>☑</td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>std::file::read</td><td>☑</td><td>☑</td><td>☑</td><td></td><td>☑</td><td></td><td>☑</td></tr>
<tr><td>sgx::fs::read (aes key)</td><td>☑</td><td>☑</td><td>☑</td><td></td><td>☑</td><td></td><td>☑</td></tr>
<tr><td>aes decryption</td><td>☑</td><td>☑</td><td>☑</td><td></td><td>☑</td><td></td><td>☑</td></tr>
<tr><td>aes decryption</td><td>☑</td><td>☑</td><td>☑</td><td></td><td>☑</td><td></td><td>☑</td></tr>
<tr><td>std::file::write</td><td>☑</td><td>☑</td><td>☑</td><td></td><td>☑</td><td></td><td>☑</td></tr>
<tr><td>no_ops_ocall</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>compose extrinsic</td><td>☑</td><td>☑</td><td></td><td></td><td></td><td></td><td>☑</td></tr>
<tr><td><strong>invokations/s</strong></td><td>332</td><td>342</td><td>365</td><td>400</td><td>5000</td><td>8196</td><td>4587</td></tr>
</tbody></table>
<ul>
<li><strong>call_counter</strong> represents the operations that are performed in a milestone 1 counter state update.</li>
<li><strong>call_counter_wasm</strong> represents the operations that are performed in a milestone 2 counter state update.</li>
<li><strong>sgx::fs::read:</strong> an SGX call that accesses the sealed enclave storage which is only readable by one specific enclave instance.</li>
<li><strong>ecall</strong> general entry point from the host system to an enclave.</li>
<li><strong>no_ops_ocall:</strong> an ocall (a call from the enclave to the host) that does nothing in order to see the impact of an ocall itself.</li>
<li><strong>invokations/s:</strong> stands for the number of executions per seconds that can be achieved. This does roughly correspond to tx/s.</li>
</ul>
<h2><a class="header" href="#analysis-1" id="analysis-1">Analysis</a></h2>
<ul>
<li>RSA decryption is by far the most expensive step in the whole pipeline. This, however, is hard to migitate as long as no more efficient asymmetric encryption exists.</li>
<li>The effect of sgx::fs::read does only have a small impact.</li>
<li>wasm invokation's impact is negligible</li>
<li>If the current RSA de/-encryption process is optimized, &gt;1000 tx/s, is achievable.</li>
</ul>
<h2><a class="header" href="#testsetup" id="testsetup">Testsetup</a></h2>
<p>All tests have been performend on an Intel NUC NUC8i3BEH2, Bean Canyon i3-8109U 3.0 GHz.</p>
<h1><a class="header" href="#hw-diversification" id="hw-diversification">HW Diversification</a></h1>
<p>As of the time of writing, Intel SGX is the only TEE that allows remote attestation. This dependency on Intel is a single point of failure and as such undesirable for Integritee.</p>
<p>The Integritee team is investigating ways to provide remote attestation for ARM TrustZone and open source TEEs like Keystone.</p>
<p>Diversification would have a positive effect on TEE <em>integrity</em> because a vulnerability in one type of TEE would only affect a fraction of all TEEs. A pretty simple consensus algorithm could ensure integrity even in presence of large-scale attacks exploiting that vulnerability.</p>
<p>However, diversification could have a negative impact on <em>confidentiality</em>. If secrets are provisioned to several types of TEEs, it only takes a single TEE to leak the secret to compromise it for all.</p>
<h2><a class="header" href="#open-source-remote-attestation-process" id="open-source-remote-attestation-process">Open Source Remote Attestation Process</a></h2>
<p>See <a href="./hw_ra_by_distributor.html">Distributor-Level Remote Attestation</a></p>
<h1><a class="header" href="#distributor-level-remote-attestation" id="distributor-level-remote-attestation">Distributor-Level Remote Attestation</a></h1>
<p>If manufaturers don't offer remote attestation, the HW distributor could jump in as the second trusted entity in the supply chain.</p>
<h2><a class="header" href="#concept" id="concept">Concept</a></h2>
<p>The goal of remote attestation is to enable the verifier to trust a member. The verifier wants to trust the hardware and software, which is physically at the member's site. The assumption is that the verifier has never accessed the hardware of the member. Therefore, other parties offer a root of trust, which is implanted in the hardware. In the picture below are three other parties, where most important one is the provision entity. She is a distributor of hardware and has also the ability to program the devices. So, they take hardware from the official manufacturers and combine it with software from a source, which is trusted by the verifier. Afterwards, this bundle is purchasable by everyone, who wants to participate. In conclusion, if somebody wants to become a member of the service, he has to buy a device from provision entity. These devices are ready to perform remote attestation.</p>
<p><img src="./fig/ra-by-distributor-overview.svg" alt="Concept" /></p>
<p>The verifier is concerned about integrity and confidentiality and requires a proof that:</p>
<ol>
<li>Member’s hardware is genuine, attested by the provision entity in a manner that the verifier is able to identify devices in the field by secure cryptographic methods</li>
<li>Member’s hardware runs exactly the code as published open source by the Trusted Software Source</li>
<li>Data supplied to the TEE is treated confidentially </li>
</ol>
<p>To fulfill these requirements each role is specified in the following sections.</p>
<h2><a class="header" href="#roles" id="roles">Roles</a></h2>
<ul>
<li>Hardware Manufacturer: produces hardware</li>
<li>Trusted Software Source: writes open source software that is supposed to be run on TEEs</li>
<li>Provision Entity: Distributor with the possibility to provision devices</li>
<li>Member: operates TEE hardware on their own premises and always has physical access to it</li>
<li>Verifier: wants to run software from the Trusted Software Source with its own confidential data on member's hardware</li>
</ul>
<h3><a class="header" href="#hardware-manufacturer" id="hardware-manufacturer">Hardware Manufacturer</a></h3>
<p>The hardware manufacturer has to be trusted.</p>
<h3><a class="header" href="#trusted-software-source" id="trusted-software-source">Trusted Software Source</a></h3>
<p>To generate an open source flash image, which is signed, is problematic. Because the one who is signing is a new root of trust. Therefore, in this concept this root is spread over a multiple participants to get to an open source like root of trust. The parties should be as independent as possible. The diagram below visualizes our approach. On the left side is the open source code visible for everyone. Everything that follows is constructed under the assumption that the parties have established secure communication channels. All parties (Web3, SCS, ...) collaborate in the Multi-Party-Computation (MPC) RSA generation. As a result, everyone receives the public key and a part of the private key. Therefore, they can only together generate a signature. This is used to build a binary that only can be signed by all parties together. They take the source code and build it deterministically. Afterwards, they sign their binary and exchange it with each other. Then, they check the binaries from the other parties, if they are the same, they combine the signatures to the final signature. This signature can be verified with the public key.</p>
<p><img src="./fig/ra-by-distributor-trusted-software-source.svg" alt="Concept" /></p>
<h3><a class="header" href="#provision-entity" id="provision-entity">Provision Entity</a></h3>
<p>The provision entity has the task to prepare the devices for remote attestation. This makes her the main root of trust. Therefore she has to be trustworthy and she also needs appropriate hardware. Which means that she needs at least HSM (Hardware Security Module). Better she has an access authorisation system for the facilities. To provision devices, the provision entity has to execute the following steps.</p>
<ul>
<li>Get hardware from the hardware manufacturer</li>
<li>Get the software from the trusted software source</li>
<li>Check the hardware and the software</li>
<li>Enable secure boot</li>
<li>Generate the attestation data</li>
<li>Sell the devices publicly</li>
</ul>
<p><img src="./fig/ra-by-distributor-pe-1.svg" alt="Concept" /></p>
<p>The first two steps are obvious. Get the hard and software from the corresponding sources. The next step is important. The provision entity has to check, if the hardware is not tampered. Because later, with her signature, she states that the hardware is trustworthy.</p>
<p>The next step is to enable secure boot. This means that the provision entity takes the public key from the trusted software source (the one generated in the MPC process) burn it into the devices. Also eFuses are burnt to harden the device. This step is hardware dependent. In some devices only the hash of this public key is burnt in, but its enough to enable secure boot. In the literature this key is often referred as the vendor key.</p>
<p>Afterwards, the attestation data is made. The provision entity generates with the HSM a per device unique key pair. This key pair is called the Attestation Identifier Key, because it is used to identify the device for attestation. Then also a device unique key called Endorsement Key (EK) is used. The origin of this key is hardware dependent. In some devices this key is already embedded in the device. And in others the key can be chosen and written to OTP (One Time Programmable Memory). Where it is impossible to read it back and only accessible through the on chip crypto engine. The EK is then used to encrypt the private part of the AIK. Then the public AIK and the encrypted private AIK are signed with the provision entity Key (PE-Key). These three parts form the attestation data.</p>
<p>The PE-Key is certified by a root CA and the public part of this key has to be publicly available. The verifier later needs this key.</p>
<p>The attestation data is added to the device. Because the attestation data is not confidential. It can be saved anywhere on the device.</p>
<p>Another important point is that the provision entity has to guarantee that she forget the EK and the AIK. In some devices the provision entity has never access to the EK. This is good nor bad, because it just shifts trust from the provision entity to the hardware manufacturer.</p>
<p>The last step is to sell the provisioned devices to people who want to operate the hardware. They are called members, because they can become a part of the network.</p>
<p><img src="./fig/ra-by-distributor-pe-2.svg" alt="Concept" /></p>
<h3><a class="header" href="#member" id="member">Member</a></h3>
<p>The member buys a device from the provision entity. This device can only boot from signed images, which are signed by the trusted software source. These images then perform a secure boot. This image sets up a system, that is split in two halves. In one half starts a rich OS, which is considered untrusted. In the other half starts a secure OS. This half is protected from the other side with ARM Trust Zone. The secure OS such as OPTEE, is able to host different TEEs in parallel and ensures encapsulation of these TEEs.</p>
<p><img src="./fig/ra-by-distributor-member.svg" alt="Concept" /></p>
<h3><a class="header" href="#verifier" id="verifier">Verifier</a></h3>
<p>To do an actual remote attestation, the verifier needs at first the public key from the provision entity. Then the verifier waits on request from the member. When he wants to join, he send his request, the attestation data. The verifier then validates the attestation data. If the data is valid, he knows the public AKI. To validate the public AIK, he generates a challenge. The simplest challenge is a random number. This number is sent to the member. The member decrypts the private AIK and signs the random number with it. Afterwards he sends the signature back with some system measurements. The verifier can validate the signature. If the signature is valid, the verifier can make the following assumptions:</p>
<ol>
<li>The private AIK used to forge the signature belongs to the public AIK from the attestation data, therefore there a valid key pair</li>
<li>The AIK was generated by the provision entity, because it is signed with the PE-Key</li>
<li>The device is a provisioned hardware, because the hardware is the only one which knows the EK and is able to decrypt the private AIK.</li>
<li>The hardware has booted a trustful system, because the eFuses were burnt by the provision entity</li>
</ol>
<p><img src="./fig/ra-by-distributor-verifier.svg" alt="Concept" /></p>
<h1><a class="header" href="#sidechain" id="sidechain">Sidechain</a></h1>
<h2><a class="header" href="#introduction-and-terminology" id="introduction-and-terminology">Introduction and terminology</a></h2>
<p>This section explains what a sidechain is and how it can be used to enable a coordinated multi-validateer setup. First some clarification of terminology:</p>
<ul>
<li><strong>Validateer</strong>: Combination of the two terms <em>validator</em> and <em>TEE</em>. A <a href="https://wiki.polkadot.network/docs/learn-validator">validator</a> in <a href="https://polkadot.network/">Polkadot</a> is an agent that produces blocks for the blockchain, and <em>TEE</em> is 'Trusted Execution Environment'. So, a validateer is an agent that produces blocks in a trusted execution environment. This represents a specialization of the more general Integritee 'worker', which does not necessarily incorporate a sidechain.</li>
<li><strong>Sidechain</strong>: The sidechain is a blockchain collectively maintained by validateers (i.e. workers that produce sidechain blocks). In the context of Polkadot, this would be a layer 2 blockchain (0 being the relay chain, 1 the 'parent chain' or Parachain).</li>
<li><strong>Parentchain</strong>: The layer 1 blockchain that is used by any Integritee worker (including the validateer). When run in the Polkadot ecosystem, this is the Parachain - otherwise it's a solo chain.</li>
</ul>
<h2><a class="header" href="#motivation" id="motivation">Motivation</a></h2>
<p>What are the applications of such a sidechain, what are its benefits? In short, the sidechain allows us to synchronize state transitions and updates across multiple validateers. </p>
<p>Being a blockchain, the sidechain can guarantee the consistency, ordering of state transition executions, and traceability. We can decentralize a specific business logic and run it on many validateers independently while maintaining state consistency. A further benefit of running multiple validateers is scalability and load-balancing.</p>
<h2><a class="header" href="#multi-validateer-setup-with-sidechain" id="multi-validateer-setup-with-sidechain">Multi-validateer setup with sidechain</a></h2>
<p><img src="./fig/sidechain-multi-validateer-setup.png" alt="Multi-validateer setup diagram" /></p>
<p>Validateers use their light-client and 'node API' to communicate with the parentchain, which is maintained by a substrate node.</p>
<h2><a class="header" href="#block-production" id="block-production">Block production</a></h2>
<p>The block time of the parentchain is currently set to <code>12s</code>. The validateers themselves produce sidechain blocks in intervals of <code>300ms</code>. The block production and consensus algorithm used to produce sidechain blocks, is <a href="https://docs.substrate.io/v3/advanced/consensus/#aura">AURA</a>. This means we have a defined set of authorities (i.e. validateers) that take turns in producing blocks. Each validateer (or more general, Integritee worker) is registered to the parentchain, thus defining the set of authorities. Time is then partitioned into slots of <code>300ms</code> and each slot is assigned to a validateer in a round-robin fashion. As an example, with 3 validateers, each validateer will produce a sidechain block every third slot.</p>
<p>When a validateer produces a sidechain block, it broadcasts this new block to all of its peer validateers. How does it know its peers? As mentioned above, all validateers are registered on the parentchain. A validateer queries the parentchain to get the identities and URIs to communicate with all its peers.</p>
<h4><a class="header" href="#block-production-cycle" id="block-production-cycle">Block production cycle</a></h4>
<p>Depiction of the cycle each validateer runs for a slot. This is done in the <code>slot worker</code> component of a validateer. A cycle is triggered every <code>300ms</code>.</p>
<p><img src="./fig/sidechain-block-production-cycle.png" alt="Sidechain block production cycle" /></p>
<p>Explanation of the sequence:</p>
<ol>
<li>First it processes the sidechain import queue. Sidechain blocks from the queue are imported until the queue is empty.
<ul>
<li>Importing a sidechain block results in applying the state diff and removing executed operations from the trusted operation pool.</li>
<li>It also includes potential fetching of sidechain blocks from a peer in case missing blocks were detected.</li>
</ul>
</li>
<li>The next step is determining if the current slot should be claimed, meaning determining if it is this validateers turn to produce a block. If not, the slot cycle ends here.</li>
<li>In case the slot is claimed, a validateer starts executing trusted operations from the trusted operation pool until the allocated time limit is reached. 
<ul>
<li>The time limit is a configurable fraction of the slot time, currently set to 80%. </li>
<li>The result of the trusted operations is a state diff which will be included in the sidechain block. With this information the sidechain block will be composed.</li>
<li>Once a sidechain block is composed, the validateer checks the slot time to ensure it's still within its claimed slot. If not, the block is discarded and the cycle ends. Otherwise, this new sidechain block is broadcasted to all peers, a parentchain extrinsic with confirmation of all executed operations composed and sent. </li>
</ul>
</li>
</ol>
<p><strong>Note</strong> on the slot time: At various points during the cycle the slot time is checked, to ensure the slot time of <code>300ms</code> is not exceeded. There are several cases where it still can happen. In order to prevent forks in the sidechain from happening, a sidechain block is only produced and broadcast when all the steps can be executed within the <code>300ms</code> time window. Otherwise it is discarded or not produced in the first place.</p>
<h5><a class="header" href="#scenarios-where-the-slot-time-can-be-exceeded" id="scenarios-where-the-slot-time-can-be-exceeded">Scenarios where the slot time can be exceeded:</a></h5>
<ul>
<li><strong>Block import stage</strong>: The block import stage will import all the sidechain blocks it finds in the queue. This might also trigger a fetching of sidechain blocks from a peer when missing blocks are detected (further described in the on-boarding process). This whole process might take considerably longer than the slot time, but is necessary for further execution. If the time is exceeded here, the slot cycle will end after the import and be triggered again at the next point in time when a slot starts. This can potentially skip multiple slots including ones where this validateer should have produced a block. This is however not a problem, not producing a block during a slot does not endanger the integrity of the sidechain. And furthermore, the exceeding of the slot time because of block import should only happen in rare cases, e.g. during on-boarding or after being offline for period of time.</li>
<li><strong>Trusted operation execution</strong>: Slot time is checked after each trusted operation execution. Only a defined fraction of the slot time is allocated for trusted operation execution. It can happen however, that the last operation that is executed takes too long and exceeds the allocated slot time fraction. In that case no block will be produced.</li>
</ul>
<h3><a class="header" href="#validateer-components" id="validateer-components">Validateer components</a></h3>
<p>Let's have a brief, high-level look at the main components inside a validateer for the sidechain block production.</p>
<p><img src="./fig/sidechain-validateer-component.png" alt="Validateer component overview" /></p>
<p>The validateer component is split into two regions, untrusted and trusted. The trusted region is everything inside the enclave (TEE) and what is exclusively accessible by the enclave, such as the state. Both the trusted and untrusted regions have an RPC interface. The trusted RPC interface is used to send direct invocation calls, which are then added to the trusted operation pool. The trusted RPC interface is also used when we broadcast sidechain blocks. This then internally fills the sidechain block import queue. </p>
<p>The <code>slot worker</code> component runs for every slot, imports sidechain blocks, executes trusted operations, and updates the state, as described in the chapter above. On the untrusted side we have a store for sidechain blocks, where we cache the last <code>100</code> blocks. This can be done on the untrusted side because sidechain blocks are signed, and any tampering could be noticed by verifying the signature. This store allows us to provide an RPC interface from which sidechain blocks can be fetched. This is relevant for the on-boarding process of new validateers which will be explained later.</p>
<h2><a class="header" href="#on-boarding-of-new-validateers" id="on-boarding-of-new-validateers">On-boarding of new validateers</a></h2>
<p>On-boarding is the process that happens when a new validateer is started and joins the set of validateers that have already been producing sidechain blocks for some time. On-boarding allows a new validateer to catch up on state and sidechain blocks to then start producing sidechain blocks itself.</p>
<h3><a class="header" href="#sequence-diagram-of-on-boarding-a-new-validateer" id="sequence-diagram-of-on-boarding-a-new-validateer">Sequence diagram of on-boarding a new validateer</a></h3>
<p>In this scenario, validateer 1 has been producing sidechain blocks for some time and is then joined by validateer 2. the following diagram illustrates the sequence from the point of view of validateer 2 undergoing the on-boarding process.</p>
<p><img src="./fig/sidechain-onboarding-sequence.png" alt="On-boarding sequence diagram" /></p>
<ol>
<li>On-boarding starts off with determining if there are other running validateers that have produced sidechain blocks. This is done by querying the parentchain about the author of the last sidechain block. As a result validateer 2 learns about the identity and URI of validateer 1.
<ul>
<li>Note that in case there is no previous sidechain block and therefore no author, a validateer concludes that it's the first (or <code>primary</code>) validateer.</li>
</ul>
</li>
<li>Validateer 2 then uses this information to fetch the state encryption key and state from this peer (validateer 1).</li>
<li>Once this is done, validateer 2 registers itself to the parentchain and becomes part of the active (i.e. block producing) validateer set.</li>
<li>Upon running the first slot cycle and importing sidechain blocks from the queue, validateer 2 notices it's missing sidechain blocks. Again it communicates with its peer, validateer 1, to directly fetch these missing blocks. As explained above, validateer 1 stores a certain amount of sidechain blocks in a database. Once these peer-fetched blocks are transferred and imported, the importing from the regular import queue resumes. </li>
<li>And with that, validateer 2 is fully synced and can continue with the regular block production cycle, producing blocks itself now, every second slot.</li>
</ol>
<h4><a class="header" href="#relationship-between-state-and-sidechain-blocks" id="relationship-between-state-and-sidechain-blocks">Relationship between 'state' and sidechain blocks</a></h4>
<p>In the on-boarding process, both 'state' and sidechain blocks are transferred from one validateer to another. What is the difference and why are both required? In theory, all state information is contained in the sidechain blocks. In order to know what the current state is, all transactions/operations in the sidechain blocks from genesis can be computed and accumulated. This however means that computing the current state becomes more time consuming as the blockchain grows. That is where the 'state' comes into play. The 'state' is a snapshot of the blockchain at a certain time (or block number). For example in a blockchain with <code>100</code> blocks, a state snapshot might be taken at block number <code>95</code>. So in order to know the latest state (at block number <code>100</code>), the state snapshot is taken and the last <code>5</code> blocks are applied to this state. This dramatically reduces the amount of computation required to arrive at the latest state.</p>
<p>In the current configuration, a sidechain state snapshot is taken after each sidechain block. So why do we need to transfer the state and then still fetch missing sidechain blocks? Because in between the time of fetching the state snapshot and starting the sidechain block production cycle, more sidechain blocks were already produced. Furthermore, only a certain number (currently <code>100</code>) of sidechain blocks are cached in each validateer. This cache size has to be large enough to bridge the gap between receiving the state snapshot and starting the block production cycle. A cache size of <code>100</code> blocks and a block production time of <code>300ms</code> means that a gap of maximum <code>30s</code> can be bridged, which imposes an upper limit to the duration of the on-boarding process.</p>
<h2><a class="header" href="#how-to-guide" id="how-to-guide">How-To Guide</a></h2>
<p><a href="./howto_sidechain_multivalidateer.html">This</a> how-to guide explains how to set up multiple validateers with a substrate node and then execute the sidechain demo script.</p>
<h2><a class="header" href="#youtube-demo" id="youtube-demo">Youtube Demo</a></h2>
<p>A screen cast of the sidechain demo is available on Youtube, <a href="https://www.youtube.com/watch?v=HBH8R0RJ1mY">here</a>, where some of the aspects mentioned above are explained in more detail using the sidechain demo script and the resulting log output.</p>
<h1><a class="header" href="#sidechain-system-and-networking-overview" id="sidechain-system-and-networking-overview">Sidechain system and networking overview</a></h1>
<p><img src="./fig/sidechain-system-networking.svg" alt="Sidechain system and networking diagram" /></p>
<p>Diagram showing the system and networking overview of the integritee systems:</p>
<ul>
<li><strong>integritee-service</strong> : The core Integritee service, hosting the TEE (enclave). Called <code>validateer</code> in case sidechain blocks are produced</li>
<li><strong>integritee-node</strong> : Substrate node for the layer 1 (aka parent) blockchain</li>
<li><strong>integritee-cli</strong> : Command-line interface client to interact with both the <strong>Integritee-service</strong> and the <strong>integritee-node</strong></li>
</ul>
<p>Server ports in the diagram are default values. They can also be set explicitly by command line arguments.</p>
<p>The <strong>Prometheus Service</strong> is an external monitoring service, scraping metrics from the <strong>integritee-service</strong> and <strong>integritee-node</strong>.</p>
<p>The <strong>integritee-service</strong> communicates among instances of itself. The following use-cases rely on this peer-to-peer communication:</p>
<ul>
<li>Mutual remote attestation (MU-RA), uses TLS secured websocket connection</li>
<li>Sidechain block broadcasting, receiving end is an secure websocket server on the trusted side (enclave)</li>
<li>Sidechain block fetching for on-boarding (provided by untrusted sidechain block storage)</li>
</ul>
<p>The <strong>integritee-cli</strong> uses RPC to communicate with both the <strong>integritee-node</strong>, for parentchain state queries and indirect invocation, and the <strong>integritee-service</strong>, for direct invocation and sidechain state queries.</p>
<h2><a class="header" href="#networking-example-for-a-multi-validateer-setup-with-local-nodes" id="networking-example-for-a-multi-validateer-setup-with-local-nodes">Networking example for a multi-validateer setup with local nodes</a></h2>
<p>The following diagram depicts a multi-validateer setup with <code>integritee-nodes</code> running locally (i.e. on the same machine or container as the validateer itself). The <code>integritee-nodes</code> maintain the parentchain, the validateers the sidechain. Both blockchains use peer-to-peer communication to exchange blocks on their respective blockchain. A client like the <code>integritee-cli</code> can send extrinsics to any <code>integritee-node</code> (indirect invocation). The diagram shows the case of one that is running independently of any validateers. Or it can send an extrinsic directly to a validateer, using its RPC interface (direct invocation), again it does not matter which one, they are all synchronized.</p>
<p><img src="./fig/sidechain-multi-validateer-networking.svg" alt="Sidechain multi-validateer networking diagram" /></p>
<h1><a class="header" href="#how-to" id="how-to">How to</a></h1>
<p>Here you'll find some hands-on tutorials on how to use Integritee for your use case</p>
<h1><a class="header" href="#how-to-build-and-run-a-integritee-node" id="how-to-build-and-run-a-integritee-node">How to Build and Run a integritee-node</a></h1>
<p>You don't need SGX to run a node (only workers do).</p>
<h2><a class="header" href="#build" id="build">Build</a></h2>
<p>Install Rust:</p>
<pre><code class="language-bash">curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>In order to compile <em>ring</em> into wasm, you'll need LLVM-9 or above or you'll get linker errors. Here the instructions for Ubuntu 18.04</p>
<pre><code class="language-bash">wget https://apt.llvm.org/llvm.sh
chmod +x llvm.sh
sudo ./llvm.sh 10
export CC=/usr/bin/clang-10
export AR=/usr/bin/llvm-ar-10
# if you already built, make sure to run cargo clean
</code></pre>
<p>Initialize your Wasm Build environment:</p>
<pre><code class="language-bash">rustup show
</code></pre>
<p>Build Wasm and native code:</p>
<pre><code class="language-bash">cargo build --release
</code></pre>
<h3><a class="header" href="#with-docker" id="with-docker">with docker</a></h3>
<p>If you prefer to skip the setup, you can just use our docker and build the node like this (run in the repo root):</p>
<pre><code class="language-bash">docker pull integritee/integritee-dev:0.1.9
docker run -it -v $(pwd):/root/work integritee/integritee-dev:0.1.9 /bin/bash
rustup show
cargo build --release
</code></pre>
<h2><a class="header" href="#run" id="run">Run</a></h2>
<h3><a class="header" href="#single-node-development-chain" id="single-node-development-chain">Single Node Development Chain</a></h3>
<p>Purge any existing developer chain state:</p>
<pre><code class="language-bash">./target/release/integritee-node purge-chain --dev
</code></pre>
<p>Start a development chain with:</p>
<pre><code class="language-bash">./target/release/integritee-node --dev
</code></pre>
<p>If you want the integritee-node to expose a different websocket port, use the option <code>--ws-port xxx</code>. If external workers or clients need to access, add the option <code>--ws-external</code>.</p>
<p>Detailed logs may be shown by running the node with the following environment variables set: <code>RUST_LOG=debug RUST_BACKTRACE=1 cargo run -- --dev</code>.</p>
<h3><a class="header" href="#node-as-a-system-service" id="node-as-a-system-service">Node as a System Service</a></h3>
<p>If you want to run your node as a system service in Linux, create (as root or user with sudo permissions) a file in <code>/etc/systemd/system</code> called <code>integritee-node.service</code> with the following content:</p>
<pre><code class="language-bash">[Unit]
Description=Integritee Node
After=network.target
StartLimitIntervalSec=0

[Service]
Type=simple
Restart=always
RestartSec=10
User=&lt;USER TO RUN THE NODE&gt;
ExecStart=&lt;ABSOLUTE PATH TO&gt;/integritee-node --chain &lt;PATH TO CHAIN JSON&gt; --name &lt;NAME OF THE NODE&gt;

[Install]
WantedBy=multi-user.target
</code></pre>
<p>Where:</p>
<ul>
<li><code>StartLimitIntervalSec</code> makes that systemd will try to re-start the service forever.</li>
<li><code>RestartSec</code> indicates the interval between two restarts.</li>
<li><code>User</code> specifies the user that should run the node.</li>
<li><code>ExecStart</code> specifies the path to the binary. Use absolute paths here.</li>
</ul>
<p>Update the systemd daemon with <code>systemctrl daemon-reload</code>.</p>
<p>Use the following commands:</p>
<ul>
<li><code>systemctrl start integritee-node.service</code> to start the node.</li>
<li><code>systemctrl stop integritee-node.service</code> to stop the node.</li>
<li><code>systemctrl status integritee-node.service</code> to check the status of the node/service.</li>
</ul>
<h1><a class="header" href="#how-to-run-your-own-worker" id="how-to-run-your-own-worker">How To Run Your Own Worker</a></h1>
<h2><a class="header" href="#hw-requirements" id="hw-requirements">HW requirements</a></h2>
<p>While SGX is supported by most Intel CPU's that is not the case for all chipsets. Here we're just telling you what HW we are using and is known to work.</p>
<h3><a class="header" href="#dell-poweredge-r340-server" id="dell-poweredge-r340-server">Dell PowerEdge R340 Server</a></h3>
<p>CPU <strong>has to be</strong> Intel(R) Xeon(R) E-2276G CPU @ 3.80 GHz</p>
<h3><a class="header" href="#enable-sgx-support-in-bios" id="enable-sgx-support-in-bios">Enable SGX support in BIOS</a></h3>
<p>To enable SGX support in the Dell BIOS, enter the BIOS, go to <code>System Security</code> and set the following values:</p>
<ul>
<li><code>Intel SGX</code> to <code>On</code></li>
<li><code>SGX Launch Control Policy</code> to <code>Unlocked</code></li>
</ul>
<h2><a class="header" href="#intel-sgx-development-and-production-commercial-license" id="intel-sgx-development-and-production-commercial-license">Intel SGX development and production (commercial) license</a></h2>
<p>In order to perform a remote attestation of the enclave, an <a href="https://api.portal.trustedservices.intel.com/EPID-attestation">Intel SGX Attestation Enhanced Service Privacy ID (EPID)</a> is needed. We use unlinkable quotes in our code. Developers need to <a href="https://api.portal.trustedservices.intel.com/EPID-attestation">register an account with Intel</a></p>
<h3><a class="header" href="#development-access" id="development-access">Development Access</a></h3>
<p>Copy your SPID and key to the following files (use Linux line endings):</p>
<ul>
<li><code>bin/spid.txt</code>: SPID of your subscription</li>
<li><code>bin/key.txt</code>: Key of your subscription (primary or secondary works)</li>
</ul>
<p>The enclave will be signed with the development key found under <code>enclave/Enclave_private.pem</code> and uses the configuration found under <code>enclave/Enclave.config.xml</code>.</p>
<h3><a class="header" href="#production-access" id="production-access">Production Access</a></h3>
<p>You need a commercial license with Intel to run your enclaves in production mode (the only mode that really is confidential). Only legal entities can get a commercial license with Intel. Get in touch with them to obtain one.</p>
<p>Copy your SPID and key to the following files (use Linux line endings):</p>
<ul>
<li><code>bin/spid_production.txt</code>: SPID of your subscription</li>
<li><code>bin/key_production.txt</code>: Key of your subscription (primary or secondary works)</li>
</ul>
<p>These files are used to access the Intel Remote Attestation Service.</p>
<p>The enclave will be signed with the private key that was also registered and whitelisted at Intel's (in the process of obtaining a commercial license). Make sure that the key is exported as an environment variable called <code>SGX_COMMERCIAL_KEY</code>.</p>
<p>The enclave in production mode uses the configuration found under <code>enclave/Enclave.config.production.xml</code>.</p>
<p>The only difference is that the option <code>DisableDebug</code> is set to <code>1</code>.</p>
<h2><a class="header" href="#sw-requirements" id="sw-requirements">SW Requirements</a></h2>
<p>You need the following components installed to start developing/compiling the code:</p>
<ul>
<li><a href="https://github.com/intel/linux-sgx-driver">Intel SGX driver</a>, <a href="https://github.com/intel/linux-sgx">SGX and PSW</a></li>
<li><a href="https://www.rust-lang.org/">Rust</a></li>
<li><a href="https://github.com/apache/incubator-teaclave-sgx-sdk">Rust SGX SDK</a></li>
<li><a href="https://ipfs.io/">IPFS</a></li>
</ul>
<h3><a class="header" href="#setup-sgx-hardware-with-ansible" id="setup-sgx-hardware-with-ansible">Setup SGX hardware with Ansible</a></h3>
<p>You find a sample Ansible playbook <a href="https://github.com/scs/intel_sgx_setup">here</a></p>
<p>Open the playbook with your editor and replace all the variables with <code>&lt;...&gt;</code> with your own settings.</p>
<p>To execute the playbook and configure the remote machine, use the following command:</p>
<pre><code class="language-bash">ansible-playbook site.yml -k
</code></pre>
<h3><a class="header" href="#using-docker" id="using-docker">Using Docker</a></h3>
<p>We provide docker images with all the required tools installed. They can be found on <a href="https://hub.docker.com/r/integritee/integritee-dev/tags">dockerhub</a>.</p>
<p>The tag has the following format: <code>&lt;Ubuntu version&gt;-&lt;Intel SGX SDK version&gt;-&lt;Rust SGX SDK version&gt;</code>. We don't provide any <em>latest</em> so you must specify the tag.</p>
<p>If you execute</p>
<pre><code class="language-bash">docker pull integritee/integritee-dev:0.1.9
</code></pre>
<p>you get a docker image with</p>
<ul>
<li>Ubuntu 18.04</li>
<li>Intel SGX SDK 2.12</li>
<li>Rust SGX SDK 1.1.3 (which includes the correct Rust version)</li>
<li>container version 001</li>
<li>IPFS 0.4.21</li>
</ul>
<p>The following builds the code inside the docker, but the compiled binaries are stored on your local working copy.</p>
<pre><code class="language-bash">docker run -it -v $(pwd):/root/work integritee/integritee-dev:0.1.9 /bin/bash
</code></pre>
<p>Now you can build and run your worker inside docker.</p>
<h4><a class="header" href="#enabling-sgx-hw-support-in-docker" id="enabling-sgx-hw-support-in-docker">Enabling SGX HW Support in Docker</a></h4>
<p>If you are on a platform that supports SGX, you can enable HW support by:</p>
<ul>
<li>
<p>Enable the SGX support in the BIOS</p>
</li>
<li>
<p>Instal the <a href="https://github.com/intel/linux-sgx-driver">Intel SGX Driver</a> and the <a href="https://github.com/intel/linux-sgx">Intel SGX SDK</a> and make sure that <code>/dev/isgx</code> appears</p>
</li>
<li>
<p>Start the docker with SGX device support:</p>
<pre><code class="language-bash">docker run -it -v $(pwd):/root/work --device /dev/isgx integritee/integritee-dev:0.1.9 /bin/bash
</code></pre>
</li>
<li>
<p>Start the aesm service inside the docker:</p>
<pre><code class="language-bash">LD_LIBRARY_PATH=/opt/intel/sgx-aesm-service/aesm/ /opt/intel/sgx-aesm-service/aesm/aesm_service &amp;
</code></pre>
</li>
<li>
<p>Compile the integritee-worker:</p>
<pre><code class="language-bash">make
</code></pre>
</li>
<li>
<p>run worker like described below</p>
</li>
</ul>
<p>If you run the Hardware Mode on a platform that does not support SGX, you get the following error from the integritee-worker</p>
<pre><code class="language-bash">*** Start the enclave
[2019-05-15T05:15:03Z ERROR integritee::enclave_wrappers] [-] Init Enclave Failed SGX_ERROR_NO_DEVICE!
</code></pre>
<h2><a class="header" href="#build-worker" id="build-worker">Build Worker</a></h2>
<p>In order to compile <em>ring</em> into wasm, you'll need LLVM-9 or above or you'll get linker errors. Here the instructions for Ubuntu 18.04. Skip this if you're building in our docker.</p>
<pre><code class="language-bash">wget https://apt.llvm.org/llvm.sh
chmod +x llvm.sh
sudo ./llvm.sh 10
export CC=/usr/bin/clang-10
export AR=/usr/bin/llvm-ar-10
# if you already built, make sure to run cargo clean
</code></pre>
<pre><code class="language-bash">git clone https://github.com/integritee-network/worker.git
cd worker
make
</code></pre>
<p>this might take 10min+ on a fast machine.</p>
<p>then you'll have to provide your SPID and KEY (see above)</p>
<pre><code class="language-bash">echo &quot;&lt;YOUR SPID&gt;&quot; &gt; bin/spid.txt
echo &quot;&lt;YOUR KEY&gt;&quot; &gt; bin/key.txt
</code></pre>
<h2><a class="header" href="#run-worker" id="run-worker">Run Worker</a></h2>
<pre><code class="language-bash">cd bin
./integritee-service init-shard
./integritee-service shielding-key
./integritee-service signing-key
./integritee-service run --ns &lt;yournodeip&gt;
</code></pre>
<h2><a class="header" href="#worker-direct-calls-scalability" id="worker-direct-calls-scalability">Worker direct calls scalability</a></h2>
<p>For direct calls, a worker runs a web-socket server inside the enclave. An important factor for scalability is the transaction throughput of a single worker instance, which is in part defined by the maximum number of concurrent socket connections possible. On Linux by default, a process can have a maximum of <code>1024</code> concurrent file descriptors (show by <code>ulimit -n</code>).
If the web-socket server hits that limit, incoming connections will be declined until one of the established connections is closed. Permanently changing the <code>ulimit -n</code> value can be done in the <code>/etc/security/limits.conf</code> configuration file. See <a href="https://linuxhint.com/permanently_set_ulimit_value/">this</a> guide for more information.</p>
<h1><a class="header" href="#how-to-perform-private-transactions" id="how-to-perform-private-transactions">How to Perform Private Transactions</a></h1>
<p>Private transactions are a change of ownership of tokens where no one but the involved parties can learn who sent how many tokens to whom.</p>
<p>Substrate blockchains are usually account-based and pseudonymous by nature: The whole world can see all transactions and their source, destination and amount. Integritee offers confidentiality in a similar way that Zcash does: it offers users a way to move their tokens into a dark pool (shielding process) where they can transact privately and later retrieve tokens on their public accounts (unshielding). In the case of Zcash, privacy is guaranteed by zk-SNARKS, in Integritee it is guaranteed by TEEs.</p>
<p>The detailed design of the shielding and unshielding process is described in the chapter <a href="./token_shielding.html">Token Shielding</a>.</p>
<p>In the following demo we show how Alice can send tokens to Bob privately. The demo will run in our docker container so you don't need to setup a complete SGX development machine (although the Intel SGX driver and SDK needs to be installed making <code>/dev/isgx</code> and the aesm service available).</p>
<h2><a class="header" href="#setup" id="setup">Setup</a></h2>
<p>Build worker, client and node in our docker, so you don't need any Intel SGX hardware:</p>
<pre><code class="language-bash"># get the docker image
# check for updates on https://hub.docker.com/r/integritee/integritee-dev/tags
docker pull integritee/integritee-dev:0.1.9

# create a dedicated demo directory and start the docker container
mkdir demo &amp;&amp; cd demo
docker run -it -v $(pwd):/root/work integritee/integritee-dev:0.1.9 /bin/bash

# now you are inside the container
# clone and build the worker and the client
cd work
git clone https://github.com/integritee-network/worker.git
cd worker
# Install the correct rust-toolchain
rustup show
SGX_MODE=SW make
# this might take 10min+ on a fast machine

# clone and build the node
cd ..
git clone https://github.com/integritee-network/integritee-node.git
cd integritee-node
# build the node
cargo build --release --features skip-ias-check,skip-extrinsic-filtering
# another 10min
</code></pre>
<p>For a nicer overview of the demo, let's install tmux and split our docker console into multiple terminals</p>
<pre><code class="language-bash">apt update
apt install -y tmux
tmux
tmux split-window -v
tmux split-window -h
</code></pre>
<p>You should now see three terminals</p>
<h2><a class="header" href="#launch-node-in-terminal-1" id="launch-node-in-terminal-1">Launch node in terminal 1</a></h2>
<pre><code class="language-bash">cd ~/work/integritee-node/
./target/release/integritee-node --dev -lruntime=debug
</code></pre>
<p>blocks should be produced...</p>
<h2><a class="header" href="#launch-worker-in-terminal-2" id="launch-worker-in-terminal-2">Launch worker in terminal 2</a></h2>
<p>use <code>Ctrl-B + cursors</code> to move between terminals</p>
<pre><code class="language-bash">cd ~/work/worker/bin
# create empty INTEL key files
touch spid.txt key.txt
./integritee-service init-shard
./integritee-service shielding-key
./integritee-service signing-key
./integritee-service mrenclave &gt; ~/mrenclave.b58
./integritee-service run --skip-ra --dev
</code></pre>
<h2><a class="header" href="#play-in-terminal-3" id="play-in-terminal-3">Play in terminal 3</a></h2>
<pre><code class="language-bash">cd ~/work/worker/cli
./demo_shielding_unshielding.sh
</code></pre>
<p>Now you can watch the process of</p>
<ol>
<li>Alice creating a new <em>incognito</em> account. This account is never disclosed to the public.</li>
<li>Alice shielding funds onto her <em>incognito</em> account</li>
<li>Alice privately sending funds to Bobs <em>incognito</em> account</li>
<li>Alice unshielding some funds back onto her public account</li>
</ol>
<h2><a class="header" href="#cleanup" id="cleanup">Cleanup</a></h2>
<p>The files created in the docker container belong to <code>root</code>. This makes it hard to delete them on your normal system. We now give them back to your standard user.</p>
<p>Note: This step is optional.</p>
<pre><code class="language-bash">cd /root/work
ls -la

# write down the numbers on the line containing '.'
# example output: drwxrwxr-x 17 1002 1002   4096 Nov  2 15:10 .
#  where the numbers are 1002 (NUMBER1) and 1002 (NUMBER2)

# give all files back to the external user
chown -R &lt;NUMBER1&gt;:&lt;NUMBER2&gt; integritee-service integritee-node
</code></pre>
<h1><a class="header" href="#how-to-perform-direct-transactions" id="how-to-perform-direct-transactions">How to Perform Direct Transactions</a></h1>
<p><em>this demo is intended to be an acceptance test for M8.1 and M8.2. The underlying features are not production-ready. M8.1 and M8.2 are just our first milestones towards direct invocation and sidechains according to our <a href="https://polkadot.polkassembly.io/post/111">scalability roadmap</a></em></p>
<p>This direct invocation demo is similar to <a href="./howto_private_tx.html">Private Transaction</a>: We demonstrate a change of ownership of tokens where no one but the involved parties can learn who sent how many tokens to whom. The difference lies in the way the transaction is transferred. With indirect invocation, calls are sent to the blockchain to get consensus over tx order. With direct invocation (this demo), the client call is directly sent to the TEE which takes care of tx ordering as a trusted entity.</p>
<p>For direct invocation, our worker exposes a rpc interface for submitting and watching a <code>TrustedCall</code>. Our client uses direct invocation whenever the <code>--direct</code> flag is present.</p>
<p>Substrate blockchains are usually account-based and pseudonymous by nature: The whole world can see all transactions and their source, destination and amount. Integritee offers confidentiality in a similar way that Zcash does: it offers users a way to move their tokens into a dark pool (shielding process) where they can transact privately and later retrieve tokens on their public accounts (unshielding). In the case of Zcash, privacy is guaranteed by zk-SNARKS, in Integritee it is guaranteed by TEEs.</p>
<p>The detailed design of the shielding and unshielding process is described in the chapter <a href="./token_shielding.html">Token Shielding</a>.</p>
<p>In the following demo we show how Alice can send tokens to Bob privately with a direct invocation call. The demo will run in our docker container so you don't need any special hardware.</p>
<h2><a class="header" href="#setup-1" id="setup-1">Setup</a></h2>
<p>Build worker, client and node in our docker, so you don't need any Intel SGX hardware:</p>
<pre><code class="language-bash"># get the docker image
# check for updates on https://hub.docker.com/r/integritee/integritee-dev/tags
docker pull integritee/integritee-dev:0.1.9

# create a dedicated demo directory and start the docker container (with sgx support)
mkdir demo &amp;&amp; cd demo
docker run -it -v $(pwd):/root/work integritee/integritee-dev:0.1.9 /bin/bash
cd work

# clone and build the worker and the client
git clone https://github.com/integritee-network/worker.git
cd worker
# Install the correct rust-toolchain
rustup show
SGX_MODE=SW make
# this might take 10min+ on a fast machine

# clone and build the node
cd ..
git clone https://github.com/integritee-network/integritee-node.git
cd integritee-node
# Install the correct rust-toolchain
rustup show
# build the node
cargo build --release --features skip-ias-check,skip-extrinsic-filtering
# another 10min
</code></pre>
<p>For a nicer overview of the demo, let's use tmux and split our docker console into multiple terminals</p>
<pre><code class="language-bash">tmux
tmux split-window -v
tmux split-window -h
</code></pre>
<p>You should now see three terminals</p>
<h2><a class="header" href="#launch-node-in-terminal-1-1" id="launch-node-in-terminal-1-1">Launch node in terminal 1</a></h2>
<pre><code class="language-bash">cd ~/work/integritee-node/
./target/release/integritee-node --tmp --dev
</code></pre>
<p>wait until you see blocks being produced...</p>
<h2><a class="header" href="#launch-worker-in-terminal-2-1" id="launch-worker-in-terminal-2-1">Launch worker in terminal 2</a></h2>
<p>use <code>Ctrl-B + cursors</code> to move between terminals</p>
<pre><code class="language-bash">cd ~/work/worker/bin
# create empty INTEL key files
touch spid.txt key.txt
./integritee-service init-shard
./integritee-service shielding-key
./integritee-service signing-key
./integritee-service mrenclave &gt; ~/mrenclave.b58
./integritee-service run --skip-ra --dev
</code></pre>
<p>wait until you see blocks being synched</p>
<h2><a class="header" href="#run-client-in-terminal-3" id="run-client-in-terminal-3">Run client in terminal 3</a></h2>
<pre><code class="language-bash">cd ~/work/worker/cli
./demo_direct_call.sh -m file
</code></pre>
<p>Now you can watch the process of</p>
<ol>
<li>Sudo prefunding Alice</li>
<li>creating a new <em>incognito</em> account</li>
<li>Alice privately sending funds to new <em>incognito</em> account</li>
</ol>
<h2><a class="header" href="#cleanup-1" id="cleanup-1">Cleanup</a></h2>
<p>The files created in the docker container belong to <code>root</code>. This can make it impossible to delete them on your host system. We now give them back to your standard user. (Alternatively, you can just delete everything in <code>work</code>)</p>
<p>Note: This step is optional.</p>
<pre><code class="language-bash">cd /root/work
ls -la

# write down the numbers on the line containing '.'
# example output: drwxrwxr-x 17 1002 1002   4096 Nov  2 15:10 .
#  where the numbers are 1002 (NUMBER1) and 1002 (NUMBER2)

# give all files back to the external user
chown -R &lt;NUMBER1&gt;:&lt;NUMBER2&gt; integritee-service integritee-node
</code></pre>
<h1><a class="header" href="#how-to-run-a-sidechain-multi-validateer-setup" id="how-to-run-a-sidechain-multi-validateer-setup">How to run a sidechain multi-validateer setup</a></h1>
<p><em>This demo is intended to be an acceptance test for M8.3. It showcases a pair of validateers synchronizing their state using the sidechain as well as the on-boarding process according to our <a href="https://polkadot.polkassembly.io/post/111">scalability roadmap</a>.</em></p>
<p>This demo sets up an Integritee node and two validateers (i.e. Integritee workers that produce sidechain blocks). The second validateer will be started 1 minute after the first one, so it needs to catch up on what has happened in the meantime on the first one. This process is called 'on-boarding'.</p>
<p>After this setup is fully up and running, we run a demo script that transfers funds from an Alice account to a Bob account. We do that by sending a direct request (or direct transaction) to each validateer in sequence. Because the validateers synchronize their state using the sidechain, the transactions will be known to both validateers. As a result they will have a consistent and identical view of the state.</p>
<h2><a class="header" href="#setup-2" id="setup-2">Setup</a></h2>
<p>First build the Integritee node and the worker (validateer) in a docker container and software mode. This way no Intel SGX hardware is required.</p>
<p>Run on a Linux console (or WSL 2 with docker integration enabled):</p>
<pre><code class="language-bash"># get the docker image
# check for updates on https://hub.docker.com/r/integritee/integritee-dev/tags
docker pull integritee/integritee-dev:0.1.9

# create a dedicated demo directory
mkdir demo &amp;&amp; cd demo
# start the docker container (with sgx support)
# maps the current directory (demo) into the docker container and runs a bash shell
docker run -it -v $(pwd):/root/work integritee/integritee-dev:0.1.9 /bin/bash

# now inside the docker container
cd work

# clone and build the worker and the client
git clone https://github.com/integritee-network/worker.git
cd worker
# Install the correct rust-toolchain
rustup show
SGX_MODE=SW make
# this might take 10min+ on a fast machine

# clone and build the node
cd ..
git clone https://github.com/integritee-network/integritee-node.git
cd integritee-node
# Install the correct rust-toolchain
rustup show
# build the node
cargo build --release --features skip-ias-check,skip-extrinsic-filtering
# another 10min
</code></pre>
<p>For a nicer overview of the demo, let's use tmux and split our docker console into multiple terminals</p>
<pre><code class="language-bash">tmux
tmux split-window -h
</code></pre>
<h2><a class="header" href="#launch-local-setup-in-terminal-1" id="launch-local-setup-in-terminal-1">Launch local setup in terminal 1</a></h2>
<p>Prepare the worker by generating all the necessary keys and files used for startup:</p>
<pre><code class="language-bash">cd ~/work/worker/bin
# create empty INTEL key files
touch spid.txt key.txt
./integritee-service init-shard
./integritee-service shielding-key
./integritee-service signing-key
./integritee-service mrenclave &gt; ~/mrenclave.b58
</code></pre>
<p>Use the <code>local-setup</code> scripts to launch an integritee node and 2 workers. The workers are started with a 1 minute delay in between them.</p>
<pre><code class="language-bash">cd ~/work/worker
./local-setup/launch.py ./local-setup/tutorial-config.json
</code></pre>
<p>Wait until you see the message &quot;<code>Starting worker 2 in background</code>&quot; and then wait another minute or so.</p>
<h2><a class="header" href="#launch-sidechain-demo-script-in-terminal-2" id="launch-sidechain-demo-script-in-terminal-2">Launch sidechain demo script in terminal 2</a></h2>
<p>Switch to terminal 2 (using <code>Ctrl-B + cursor right</code>) and run the demo script <code>sidechain.sh</code>.</p>
<pre><code class="language-bash">cd ~/work/worker/scripts
source ./init_env.sh &amp;&amp; ./sidechain.sh
</code></pre>
<p>You will see output from the demo script, transferring funds using both workers and in the end verifying that the balances of both accounts (Alice and Bob) match the expected result.</p>
<p>The <code>tmux</code> session can be ended using <code>Ctrl-B + : </code> to enter command mode, and then <code>kill-session</code>.</p>
<h2><a class="header" href="#cleanup-optional" id="cleanup-optional">Cleanup (optional)</a></h2>
<p>The files created in the docker container belong to <code>root</code>. This can make it hard to delete them from your host system. You can change ownership of those folders back to your regular user.</p>
<pre><code class="language-bash">cd /root/work
ls -la

# write down the numbers on the line containing '.'
# example output: drwxrwxr-x 17 1002 1002   4096 Nov  2 15:10 .
#  where the numbers are 1002 (NUMBER1) and 1002 (NUMBER2)

# give ownership back to the external user
chown -R &lt;NUMBER1&gt;:&lt;NUMBER2&gt; integritee-service integritee-node
</code></pre>
<h1><a class="header" href="#how-to-access-on-chain-storage-from-within-the-enclave-trustlessly" id="how-to-access-on-chain-storage-from-within-the-enclave-trustlessly">How To Access On-Chain Storage From Within The Enclave Trustlessly</a></h1>
<p>Integritee isolates <em>confidential state</em> (what the STF <code>TrustedCall</code> operates on inside the SGX enclave) from <em>on-chain state</em> (what is plaintext readable by the entire network of integritee-nodes). Some use cases, however, reqire read access to on-chain storage for their <code>TrustedCall</code>s. As the enclave can't trust its worker service, it has to request and verify read proofs from the integritee-node.</p>
<p>Our goal is that you can use the same pallets that you use on-chain also inside Integritee enclaves. Therefore, we are mapping storage keys directly between confidential state and on-chain state. Your <code>TrustedCall</code> has to specify what storage keys it requires and these will be mapped to the confidential state before executing the call.</p>
<p>For this to work, the <a href="https://github.com/integritee-network/sgx-runtime/tree/master/runtime">sgx-runtime</a> must be compatible with the <a href="https://github.com/integritee-network/integritee-node/tree/master/runtime">node-runtime</a>. This means that the same substrate version must be used. However, it does not mean that the same pallets must be instantiated.</p>
<p>Until <a href="https://github.com/integritee-network/worker/issues/113">#113</a> is resolved, we also have the restriction that <code>StorageMap</code> and <code>StorageDoubleMap</code> must use <code>StorageHasher::Blake2_128Concat</code>.</p>
<h2><a class="header" href="#trusted-time-example" id="trusted-time-example">Trusted Time Example</a></h2>
<p>Inside the enclave we don't have a trusted time source (We could use Intel's AESM with <code>sgx_get_trusted_time</code> but that would extend our trust assumptions). The blockchain delivers trusted time because every block includes a UTC timestamp which is agreed upon by consensus (within a certain tolerance).</p>
<p>For this example, we access on-chain time using substrate's <a href="https://crates.parity.io/pallet_timestamp/index.html">timestamp</a> pallet. More precisely, we will enable you to call <code>Timestamp::&lt;T&gt;::now()</code> from any pallet in your STF. You will get the UTC timestamp from the block that includes your <code>TrustedCall</code>.</p>
<h3><a class="header" href="#key-mapping" id="key-mapping">Key Mapping</a></h3>
<p>In your STF, you'll have to define what on-chain storage keys shall be mapped for each <code>TrustedCall</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn get_storage_hashes_to_update(call: &amp;TrustedCall) -&gt; Vec&lt;Vec&lt;u8&gt;&gt; {
    let mut key_hashes = Vec::new();
    match call {
        TrustedCall::your_time_aware_call(_) =&gt; {
            key_hashes.push(
                storage_value_key(&quot;Timestamp&quot;,&quot;Now&quot;));
        }
        // more calls ....
    };
    key_hashes
}
<span class="boring">}
</span></code></pre></pre>
<p>In your pallet you can now query timestamp as usual</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>decl_module! {
    pub struct Module&lt;T: Trait&gt; for enum Call where origin: T::Origin {
        #[weight = 10_000]
        pub fn your_time_aware_call(origin) -&gt; dispatch::DispatchResult {
            ensure!(Timestamp::&lt;T&gt;::now() &gt; EARLIEST_TIME_OF_EXECUTION,
                &quot;too early to call this&quot;);
            // ...
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#how-to-build-your-own-trusted-stf" id="how-to-build-your-own-trusted-stf">How To Build Your Own Trusted STF</a></h1>
<p>Integritee is a framework that makes it easy for you to gain confidentiality for your decentralization endeavours.</p>
<p>The development process integrates well with substrate:</p>
<ol>
<li>develop and debug your use case on substrate, writing your own pallets</li>
<li>Once the logic works, move your sensitive pallets to Integritee without modification and you'll get confidential state (and state updates)</li>
</ol>
<p>In the following we will assume that you know <a href="https://substrate.dev/docs/en/tutorials/add-a-pallet/import-a-pallet">how to build custom substrate blockchains</a> and we will skip boring explanations.</p>
<h2><a class="header" href="#example-use-case-encointer" id="example-use-case-encointer">Example Use Case Encointer</a></h2>
<p>We will walk you through this process with a real-world example: <a href="https://encointer.org">Encointer</a></p>
<p>Encointer has been developed as a substrate chain with 4 custom pallets added to the node-template:</p>
<p><img src="./fig/Testnet-Gesell-Component-Interactions.svg" alt="gesell" /></p>
<p>We will now show you how we can turn Testnet Gesell (all public) in to Testnet Cantillon, featuring confidentiality for sensitive pallets.</p>
<p>In order to protect the privacy of users we will move the balances and ceremony pallets into the integritee-enclave. These pallets will still need to interact with the on-chain state, as indicated in the diagram below:</p>
<p><img src="./fig/Testnet-Cantillon-Component-Interactions.svg" alt="cantillon" /></p>
<p>The final code can be inspected on <a href="https://github.com/encointer/encointer-worker/tree/master/stf">encointer github</a></p>
<h2><a class="header" href="#tee-runtime" id="tee-runtime">TEE Runtime</a></h2>
<p>Substrate chains wrap all their business logic into a runtime made up of pallets. Integritee does so too, so let's create our TEE runtime:</p>
<pre><code class="language-bash">git clone https://github.com/integritee-network/sgx-runtime.git
</code></pre>
<p>this is actually a fork of node-template, stripped from everything we don't need for our case.</p>
<p>Now we need to include our pallets <em>balances</em> and <em>ceremonies</em> exactly the way you're used to from substrate</p>
<h4><a class="header" href="#runtimesrclibrs" id="runtimesrclibrs">runtime/src/lib.rs</a></h4>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>construct_runtime!(
    pub enum Runtime where
        Block = Block,
        NodeBlock = opaque::Block,
        UncheckedExtrinsic = UncheckedExtrinsic
    {
        System: system::{Module, Call, Config, Storage, Event&lt;T&gt;},
        Timestamp: timestamp::{Module, Call, Storage, Inherent},
        Balances: balances::{Module, Call, Storage, Config&lt;T&gt;, Event&lt;T&gt;},
        TransactionPayment: transaction_payment::{Module, Storage},
        Sudo: sudo::{Module, Call, Config&lt;T&gt;, Storage, Event&lt;T&gt;},
        EncointerCeremonies: encointer_ceremonies::{Module, Call, Storage, Config&lt;T&gt;, Event&lt;T&gt;},
        EncointerBalances: encointer_balances::{Module, Call, Storage, Event&lt;T&gt;},
    }
);
<span class="boring">}
</span></code></pre></pre>
<p>Looks familiar? If not, <a href="https://substrate.dev/docs/en/tutorials/add-a-pallet/import-a-pallet">learn from the best</a></p>
<p>We will skip the nitty gritty of including your pallets.</p>
<h2><a class="header" href="#integritee-node" id="integritee-node">integritee-node</a></h2>
<p>The blockchain we'll be using is based on parity's node-template with one integritee-specific pallet that will take care of the worker registry and will proxy <code>TrustedCalls</code></p>
<pre><code class="language-bash">git clone https://github.com/integritee-network/integritee-node
</code></pre>
<p>Encointer will add its public pallets to this node tempalte: <em>scheduler</em> and <em>currencies</em>. See <a href="https://github.com/encointer/encointer-node/tree/sgx-master">encointer-node</a></p>
<h2><a class="header" href="#integritee-worker-1" id="integritee-worker-1">integritee-worker</a></h2>
<p>The integritee-worker is the service running on a Intel SGX enabled machine. It will run our TEE-runtime inside an SGX enclave, operating on encrypted state.</p>
<p>The worker will also be our ChainRelay, a trustless bridge from the blockchain into the SGX enclave.</p>
<p>The worker itself will not need to be modified, it is the framework which runs your custom STF logic. It also offers you a customizable CLI interface</p>
<h2><a class="header" href="#trustedcall" id="trustedcall">TrustedCall</a></h2>
<p>Now we need a way to call our custom pallet functions isolated in a TEE.</p>
<p>Integritee encapsulates all the application-specific stuff in its <code>integritee-stf</code> crate that you can customize.</p>
<pre><code class="language-bash">git clone https://github.com/integritee-network/worker
</code></pre>
<p>Let's start by defining a new <code>TrustedCall</code>:</p>
<h4><a class="header" href="#encointer-workerstfsrclibrs" id="encointer-workerstfsrclibrs">encointer-worker/stf/src/lib.rs</a></h4>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[derive(Encode, Decode, Clone)]
#[allow(non_camel_case_types)]
pub enum TrustedCall {
    balance_transfer(AccountId, AccountId, CurrencyIdentifier, BalanceType),
    ceremonies_register_participant(AccountId, CurrencyIdentifier, Option&lt;ProofOfAttendance&lt;MultiSignature, AccountId32&gt;&gt;)
}

impl TrustedCall {
    fn account(&amp;self) -&gt; &amp;AccountId {
        match self {
            TrustedCall::balance_transfer(account, _, _, _) =&gt; account,
            TrustedCall::ceremonies_register_participant(account, _, _) =&gt; account,
        }
    }
...

<span class="boring">}
</span></code></pre></pre>
<p><strong>Important</strong>: The first argument of each <code>TrustedCall</code> has to be the <em>incognito</em> <code>AccountId</code> which will sign the <code>TrustedCallSigned</code> which will then be encrypted and sent to the worker through the blockchain as a proxy.</p>
<p>Now that we defined a new call we need to execute it:</p>
<h4><a class="header" href="#encointer-workerstfsrcsgxrs" id="encointer-workerstfsrcsgxrs">encointer-worker/stf/src/sgx.rs</a></h4>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    pub fn execute(ext: &amp;mut State, call: TrustedCall, _nonce: u32, calls: &amp;mut Vec&lt;OpaqueCall&gt;) {
        ext.execute_with(|| {
            let _result = match call {
                TrustedCall::balance_transfer(from, to, cid, value) =&gt; {
                    let origin = sgx_runtime::Origin::signed(AccountId32::from(from));
                    sgx_runtime::EncointerBalancesCall::&lt;Runtime&gt;::transfer(AccountId32::from(to), cid, value)
                        .dispatch(origin)
                }
                TrustedCall::ceremonies_register_participant(from, cid, proof) =&gt; {
                    let origin = sgx_runtime::Origin::signed(AccountId32::from(from));
                    sgx_runtime::EncointerCeremoniesCall::&lt;Runtime&gt;::register_participant(cid, proof)
                        .dispatch(origin)
                }
            };
        });
    }
<span class="boring">}
</span></code></pre></pre>
<p>Now you see that <code>TrustedCall::ceremonies_register_participant()</code> calls <code>register_participant()</code> in our <code>ceremonies</code> pallet.</p>
<p>This function call depends on the <code>scheduler</code> and <code>currencies</code> pallets which are not present in our TEE runtime. It is on-chain. So we need to tell Integritee that it needs to fetch on-chain storage (and verify a read-proof) before executing our call:</p>
<h4><a class="header" href="#encointer-workerstfsrcsgxrs-1" id="encointer-workerstfsrcsgxrs-1">encointer-worker/stf/src/sgx.rs</a></h4>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    pub fn get_storage_hashes_to_update(call: &amp;TrustedCall) -&gt; Vec&lt;Vec&lt;u8&gt;&gt; {
        let mut key_hashes = Vec::new();
        match call {
            TrustedCall::balance_transfer(account, _, _, _) =&gt; { },
            TrustedCall::ceremonies_register_participant(account, _, _) =&gt; {
                key_hashes.push(storage_value_key(&quot;EncointerScheduler&quot;, &quot;CurrentPhase&quot;));
                key_hashes.push(storage_value_key(&quot;EncointerScheduler&quot;, &quot;CurrentCeremonyIndex&quot;));
                key_hashes.push(storage_value_key(&quot;EncointerCurrencies&quot;, &quot;CurrencyIdentifiers&quot;));
            }
        };
        key_hashes
    }
<span class="boring">}
</span></code></pre></pre>
<p>See <a href="./howto_access_onchain_storage.html">How to access on-chain storage</a> for more details.</p>
<p><strong>Important</strong>: Make sure your on-chain runtime and TEE runtime depend on the same version of substrate. Otherwise, mapping storage keys between the two runtimes might fail.</p>
<p>Finally, we will extend our CLI client to allow us to call our function:</p>
<h4><a class="header" href="#encointer-workerstfsrcclirs" id="encointer-workerstfsrcclirs">encointer-worker/stf/src/cli.rs</a></h4>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span> ...
         .add_cmd(
            Command::new(&quot;register-participant&quot;)
                .description(&quot;register participant for next encointer ceremony&quot;)
                .options(|app| {
                    app.arg(
                        Arg::with_name(&quot;accountid&quot;)
                            .takes_value(true)
                            .required(true)
                            .value_name(&quot;SS58&quot;)
                            .help(&quot;AccountId in ss58check format&quot;),
                    )
                })
                .runner(move |_args: &amp;str, matches: &amp;ArgMatches&lt;'_&gt;| {
                    let arg_who = matches.value_of(&quot;accountid&quot;).unwrap();
                    let who = get_pair_from_str(matches, arg_who);
                    let (mrenclave, shard) = get_identifiers(matches);
                    let tcall = TrustedCall::ceremonies_register_participant(
                        sr25519_core::Public::from(who.public()),
                        shard, // for encointer we assume that every currency has its own shard. so shard == cid
                        None
                    );
                    let nonce = 0; // FIXME: hard coded for now
                    let tscall =
                        tcall.sign(&amp;sr25519_core::Pair::from(who), nonce, &amp;mrenclave, &amp;shard);
                    println!(
                        &quot;send trusted call register_participant for {}&quot;,
                        tscall.call.account(),
                    );
                    perform_operation(matches, &amp;TrustedOperationSigned::call(tscall));
                    Ok(())
                }),
        )
<span class="boring">}
</span></code></pre></pre>
<p>This will allow us to call</p>
<pre><code class="language-bash"> encointer-client trusted register-participant //AliceIncognito --mrenclave Jtpuqp6iA98JmhUYwhbcV8mvEgF9uFbksWaAeyALZQA --shard 3LjCHdiNbNLKEtwGtBf6qHGZnfKFyjLu9v3uxVgDL35C
</code></pre>
<p>The <code>--mrenclave</code> identifies the <a href="./glossary.html">TCB</a> while <code>--shard</code> identifies the local currency we're registering for.</p>
<h2><a class="header" href="#sharding-1" id="sharding-1">Sharding</a></h2>
<p>As you may have guessed by now, Encointer uses sharding. Encointer maintains a global registry of local currencies on-chain (with the <code>currencies</code> pallet). The balances for each local currency are maintained confidentially within Integritee. One shard for each currency. This means that a worker has to decide what shard it operates on.</p>
<p>See <a href="./sharding.html">Sharding</a> for more details.</p>
<h2><a class="header" href="#trustedgetter" id="trustedgetter">TrustedGetter</a></h2>
<p>Now that everything is super-isolated and confidential, how should we know if our call actually worked?</p>
<p>That's why integritee-worker exposes a websocket interface for encrypted and authenticated queries.</p>
<p>We will now implement a getter that can only be called by the <code>AccountId</code> it refers to.</p>
<h4><a class="header" href="#encointer-workerstfsrclibrs-1" id="encointer-workerstfsrclibrs-1">encointer-worker/stf/src/lib.rs</a></h4>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[derive(Encode, Decode, Clone)]
#[allow(non_camel_case_types)]
pub enum TrustedGetter {
    balance(AccountId, CurrencyIdentifier),
    ceremony_registration(AccountId, CurrencyIdentifier)
}

impl TrustedGetter {
    pub fn account(&amp;self) -&gt; &amp;AccountId {
        match self {
            TrustedGetter::balance(account, _) =&gt; account,
            TrustedGetter::ceremony_registration(account, _) =&gt; account,
        }
    }
    ...
<span class="boring">}
</span></code></pre></pre>
<p>Again, the first argument specifies the <code>AccountId</code> that is allowed to read its part of the state, authenticated by a signature.</p>
<h4><a class="header" href="#encointer-workerstfsrcsgxrs-2" id="encointer-workerstfsrcsgxrs-2">encointer-worker/stf/src/sgx.rs</a></h4>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    pub fn get_state(ext: &amp;mut State, getter: TrustedGetter) -&gt; Option&lt;Vec&lt;u8&gt;&gt; {
        ext.execute_with(|| match getter {
            TrustedGetter::balance(who, cid) =&gt; {
                Some(get_encointer_balance(&amp;who, &amp;cid).encode())
            },
            TrustedGetter::ceremony_registration(who, cid) =&gt; {
                Some(get_ceremony_registration(&amp;who, &amp;cid).encode())
            }
        })
    }
    ...

fn get_ceremony_registration(who: &amp;AccountId, cid: &amp;CurrencyIdentifier) -&gt; ParticipantIndexType {
    let cindex = match sp_io::storage::get(&amp;storage_value_key(
        &quot;EncointerScheduler&quot;,
        &quot;CurrentCeremonyIndex&quot;)) {
            Some(val) =&gt; if let Ok(v) = CeremonyIndexType::decode(&amp;mut val.as_slice()) { v } else { 0 },
            None =&gt; 0
    };
    info!(&quot;cindex = {}&quot;, cindex);
    if let Some(res) = sp_io::storage::get(&amp;storage_double_map_key(
        &quot;EncointerCeremonies&quot;,
        &quot;ParticipantIndex&quot;,
        &amp;(cid,cindex),
        &amp;StorageHasher::Blake2_128Concat,
        who,
        &amp;StorageHasher::Blake2_128Concat,
    )) {
        if let Ok(pindex) = ParticipantIndexType::decode(&amp;mut res.as_slice()) {
            pindex
        } else {
            debug!(&quot;can't decode ParticipantIndexType for {:x?}&quot;, res);
            0
        }
    } else {
        debug!(&quot;no registration for caller&quot;);
        0
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><em>Note</em>: Currently, the stf is not aware of the runtime metadata, so we have to hard-code hashers for <code>StorageMap</code> and <code>StorageDoubleMap</code>.</p>
<p>Again, we will introduce our getter in the CLI:</p>
<h4><a class="header" href="#encointer-workerstfsrcclirs-1" id="encointer-workerstfsrcclirs-1">encointer-worker/stf/src/cli.rs</a></h4>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>.add_cmd(
    Command::new(&quot;ceremony-registration&quot;)
        .description(&quot;query state if registration for this ceremony&quot;)
        .options(|app| {
            app.arg(
                Arg::with_name(&quot;accountid&quot;)
                    .takes_value(true)
                    .required(true)
                    .value_name(&quot;SS58&quot;)
                    .help(&quot;AccountId in ss58check format&quot;),
            )
        })
        .runner(move |_args: &amp;str, matches: &amp;ArgMatches&lt;'_&gt;| {
            let arg_who = matches.value_of(&quot;accountid&quot;).unwrap();
            println!(&quot;arg_who = {:?}&quot;, arg_who);
            let who = get_pair_from_str(matches, arg_who);
            let (mrenclave, shard) = get_identifiers(matches);
            let tgetter =
                TrustedGetter::ceremony_registration(sr25519_core::Public::from(who.public()), shard);
            let tsgetter = tgetter.sign(&amp;sr25519_core::Pair::from(who));
            let res = perform_operation(matches, &amp;TrustedOperationSigned::get(tsgetter));
            let ind = if let Some(v) = res {
                if let Ok(vd) = ParticipantIndexType::decode(&amp;mut v.as_slice()) {
                    vd
                } else {
                    info!(&quot;could not decode value {:x?}&quot;, v);
                    0
                }
            } else {
                0
            };
            println!(&quot;{}&quot;, ind);
            Ok(())
        }),
)
<span class="boring">}
</span></code></pre></pre>
<p>So we can query our index in the particpant registry with our CLI</p>
<pre><code class="language-bash">encointer-client trusted ceremony-registration //AliceIncognito --mrenclave Jtpuqp6iA98JmhUYwhbcV8mvEgF9uFbksWaAeyALZQA --shard 3LjCHdiNbNLKEtwGtBf6qHGZnfKFyjLu9v3uxVgDL35C
</code></pre>
<p>Happy coding!</p>
<h1><a class="header" href="#roadmap" id="roadmap">Roadmap</a></h1>
<h2><a class="header" href="#roadmap-1" id="roadmap-1">Roadmap</a></h2>
<table><thead><tr><th>Milestone</th><th>Request Invocation</th><th>STF</th><th># Workers per STF</th><th>On-chain tx per invocation</th><th>read chain state from STF</th><th>Supported TEE Manufact.</th><th>Remote Attestation Registry</th></tr></thead><tbody>
<tr><td>M1 ☑</td><td>Proxy</td><td>Rust</td><td>1</td><td>2</td><td>-</td><td>Intel</td><td>-</td></tr>
<tr><td>M2 ☑</td><td>Proxy</td><td>Rust or WASM</td><td>1</td><td>2</td><td>-</td><td>Intel</td><td>-</td></tr>
<tr><td>M3 ☑</td><td>Proxy</td><td>Rust or WASM</td><td>1</td><td>2</td><td>-</td><td>Intel</td><td>X</td></tr>
<tr><td>M4 ☑</td><td>Proxy</td><td>Rust or WASM</td><td>N (redundant)</td><td>1+N</td><td>-</td><td>Intel</td><td>X</td></tr>
<tr><td>M5 ☑</td><td>Proxy</td><td>Rust modular</td><td>N (redundant)</td><td>1+N</td><td>-</td><td>Intel</td><td>X</td></tr>
<tr><td>M6+M7 ☑</td><td>Proxy</td><td>Rust modular</td><td>N (redundant)</td><td>1+N</td><td><strong>X</strong></td><td>Intel</td><td>X</td></tr>
<tr><td>future ☐</td><td>Proxy</td><td>Rust or <strong>Ink</strong></td><td>N (redundant)</td><td>2</td><td>X</td><td>Intel + ARM TrustZone + Keystone (?)</td><td>X</td></tr>
<tr><td>future ☐</td><td><strong>Direct</strong></td><td>Rust or Ink</td><td>N (master + failover)</td><td><strong>&lt;&lt; 1</strong></td><td>X</td><td>Intel + ARM TrustZone + Keystone   (?)</td><td>X</td></tr>
</tbody></table>
<h3><a class="header" href="#m1-poc1-single-tee-confidential-state-transition-function" id="m1-poc1-single-tee-confidential-state-transition-function">M1 PoC1: single-TEE confidential state transition function</a></h3>
<p>off-chain worker runs STF within an Intel SGX enclave. The state is persisted in a sealed file which can only be read by that very enclave.</p>
<p>The demo STF will be a simple counter.</p>
<h3><a class="header" href="#m2-poc2-single-tee-confidential-state-transition-function-in-wasm" id="m2-poc2-single-tee-confidential-state-transition-function-in-wasm">M2 PoC2: single-TEE confidential state transition function in WASM</a></h3>
<p>In addition to M1, the STF is defined by WASM code which is run by a WASMI interpreter within an Intel SGX enclave.</p>
<p>The demo STF will be a simple counter.</p>
<h3><a class="header" href="#m3-remote-attestation-registry" id="m3-remote-attestation-registry">M3 Remote Attestation Registry</a></h3>
<p>substraTEE-worker can remote-attest its own enclave with Intel Attestation Service (IAS). The report signed by IAS is then registered on-chain with substraTEE-registry runtime module. Users can verify a worker’s IAS report before interacting with it. So they can be certain that the correct code is running on a genuine SGX CPU.</p>
<h3><a class="header" href="#m4-redundancy-and-secret-provisioning" id="m4-redundancy-and-secret-provisioning">M4 Redundancy and Secret Provisioning</a></h3>
<p>Several substraTEE-workers running on different machines can redundantly operate on the same STF. This guarantees that the STF survives the loss of a few SGX machines (going offline, breaking down, denial-of-service). Moreover, this improves integrity guarantees as all the workers register call receipts including the hash of the new state. A single compromised enclave can therefore only break confidentiality, but not integrity, as manipulation would be evident to anyone.
Secret sharing among a dynamic set of worker enclaves must be implemented for such redundancy.</p>
<h3><a class="header" href="#m5-modular-stf-with-private-tx-example" id="m5-modular-stf-with-private-tx-example">M5 Modular STF with private-tx example</a></h3>
<p>Since M5, the STF is modular and has its own crate which can easily be swapped. An example for private transactions has been added</p>
<h3><a class="header" href="#m6-read-chain-state-from-stf" id="m6-read-chain-state-from-stf">M6 read chain state from STF</a></h3>
<p>From M6 onwards, substraTEE STF can access chain state in a trustless way. A substrate light client verification logic will be included in the worker enclave that allows the STF to query chain state by means of subscribing to storage over RPC and verifying returned values within the enclave.</p>
<h3><a class="header" href="#future" id="future"><em>FUTURE</em></a></h3>
<h4><a class="header" href="#support-for-ink-contracts" id="support-for-ink-contracts">support for ink contracts</a></h4>
<p><em>(development not yet funded)</em></p>
<p><a href="https://medium.com/block-journal/introducing-substrate-smart-contracts-with-ink-d486289e2b59">ink!</a> is substrate's domain specific contract language on top of Rust. This milestone shall bring ink! contracts to substraTEE.</p>
<h3><a class="header" href="#other" id="other">other</a></h3>
<ul>
<li>direct invocation</li>
<li>performance benchmarks and optimization</li>
<li>testnet for stress-tests and showcasing</li>
<li>use cases: bridges, payment hubs, ...</li>
</ul>
<h1><a class="header" href="#glossary" id="glossary">Glossary</a></h1>
<table><thead><tr><th align="left"></th><th align="left"></th></tr></thead><tbody>
<tr><td align="left">IAS</td><td align="left">Intel Attestation Services</td></tr>
<tr><td align="left">MRENCLAVE</td><td align="left">enclave measurement (basically the hash of your enclave binary)</td></tr>
<tr><td align="left">pallet</td><td align="left">a module for substrate runtimes</td></tr>
<tr><td align="left">runtime</td><td align="left">the business logic of a substrate blockchain</td></tr>
<tr><td align="left">SCS</td><td align="left">Supercomputing Systems AG</td></tr>
<tr><td align="left">SGX</td><td align="left">Intel's Software Guard Extensions</td></tr>
<tr><td align="left">STF</td><td align="left">State Transition Function</td></tr>
<tr><td align="left">TCB</td><td align="left">Trusted Computing Base</td></tr>
<tr><td align="left">TEE</td><td align="left">Trusted Execution Environment</td></tr>
</tbody></table>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
