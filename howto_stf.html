<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>How To Build Your Own Trusted STF - The Integritee Book</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="introduction.html">Introduction</a></li><li class="expanded "><a href="trusted_execution.html"><strong aria-hidden="true">1.</strong> What is Trusted Execution?</a></li><li><ol class="section"><li class="expanded "><a href="remote_attestation.html"><strong aria-hidden="true">1.1.</strong> Remote Attestation</a></li></ol></li><li class="expanded "><a href="what_for.html"><strong aria-hidden="true">2.</strong> What is Integritee Good For?</a></li><li><ol class="section"><li class="expanded "><a href="privacy.html"><strong aria-hidden="true">2.1.</strong> Privacy</a></li><li class="expanded "><a href="scalability.html"><strong aria-hidden="true">2.2.</strong> Scalability</a></li><li class="expanded "><a href="interoperability.html"><strong aria-hidden="true">2.3.</strong> Interoperability</a></li><li><ol class="section"><li class="expanded "><a href="interoperability-bridges.html"><strong aria-hidden="true">2.3.1.</strong> Bridges</a></li></ol></li><li class="expanded "><a href="use_case_cdn.html"><strong aria-hidden="true">2.4.</strong> CDN</a></li></ol></li><li class="expanded "><a href="design.html"><strong aria-hidden="true">3.</strong> Design</a></li><li><ol class="section"><li class="expanded "><a href="sharding.html"><strong aria-hidden="true">3.1.</strong> Sharding</a></li><li class="expanded "><a href="token_shielding.html"><strong aria-hidden="true">3.2.</strong> Token Shielding</a></li><li class="expanded "><a href="security.html"><strong aria-hidden="true">3.3.</strong> Security</a></li><li><ol class="section"><li class="expanded "><a href="security_intel_sgx.html"><strong aria-hidden="true">3.3.1.</strong> Intel SGX</a></li><li class="expanded "><a href="security_tm_chainrelay.html"><strong aria-hidden="true">3.3.2.</strong> Threat model ChainRelay</a></li></ol></li><li class="expanded "><a href="benchmarks.html"><strong aria-hidden="true">3.4.</strong> Benchmarks</a></li><li class="expanded "><a href="hw_diversification.html"><strong aria-hidden="true">3.5.</strong> HW Diversification</a></li><li><ol class="section"><li class="expanded "><a href="hw_ra_by_distributor.html"><strong aria-hidden="true">3.5.1.</strong> Distributor-Level Remote Attestation</a></li></ol></li><li class="expanded "><a href="sidechain.html"><strong aria-hidden="true">3.6.</strong> Sidechain</a></li><li><ol class="section"><li class="expanded "><a href="sidechain_system_networking.html"><strong aria-hidden="true">3.6.1.</strong> System and Networking</a></li></ol></li></ol></li><li class="expanded "><a href="howto.html"><strong aria-hidden="true">4.</strong> Howto</a></li><li><ol class="section"><li class="expanded "><a href="howto_node.html"><strong aria-hidden="true">4.1.</strong> How To Run a Node</a></li><li class="expanded "><a href="howto_worker.html"><strong aria-hidden="true">4.2.</strong> How To Run a Worker</a></li><li class="expanded "><a href="howto_private_tx.html"><strong aria-hidden="true">4.3.</strong> How To Perform a Private Transaction</a></li><li class="expanded "><a href="howto_direct_tx.html"><strong aria-hidden="true">4.4.</strong> How To Perform Direct Invocation</a></li><li class="expanded "><a href="howto_sidechain_multivalidateer.html"><strong aria-hidden="true">4.5.</strong> How To Run a sidechain multi-validateer setup</a></li><li class="expanded "><a href="howto_access_onchain_storage.html"><strong aria-hidden="true">4.6.</strong> How To Access On-Chain Storage Trustlessly</a></li><li class="expanded "><a href="howto_stf.html" class="active"><strong aria-hidden="true">4.7.</strong> How To Build Your Own Trusted STF</a></li></ol></li><li class="expanded "><a href="roadmap.html"><strong aria-hidden="true">5.</strong> Roadmap</a></li><li class="expanded "><a href="glossary.html"><strong aria-hidden="true">6.</strong> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Integritee Book</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#how-to-build-your-own-trusted-stf" id="how-to-build-your-own-trusted-stf">How To Build Your Own Trusted STF</a></h1>
<p>Integritee is a framework that makes it easy for you to gain confidentiality for your decentralization endeavours.</p>
<p>The development process integrates well with substrate:</p>
<ol>
<li>develop and debug your use case on substrate, writing your own pallets</li>
<li>Once the logic works, move your sensitive pallets to Integritee without modification and you'll get confidential state (and state updates)</li>
</ol>
<p>In the following we will assume that you know <a href="https://substrate.dev/docs/en/tutorials/add-a-pallet/import-a-pallet">how to build custom substrate blockchains</a> and we will skip boring explanations.</p>
<h2><a class="header" href="#example-use-case-encointer" id="example-use-case-encointer">Example Use Case Encointer</a></h2>
<p>We will walk you through this process with a real-world example: <a href="https://encointer.org">Encointer</a></p>
<p>Encointer has been developed as a substrate chain with 4 custom pallets added to the node-template:</p>
<p><img src="./fig/Testnet-Gesell-Component-Interactions.svg" alt="gesell" /></p>
<p>We will now show you how we can turn Testnet Gesell (all public) in to Testnet Cantillon, featuring confidentiality for sensitive pallets.</p>
<p>In order to protect the privacy of users we will move the balances and ceremony pallets into the integritee-enclave. These pallets will still need to interact with the on-chain state, as indicated in the diagram below:</p>
<p><img src="./fig/Testnet-Cantillon-Component-Interactions.svg" alt="cantillon" /></p>
<p>The final code can be inspected on <a href="https://github.com/encointer/encointer-worker/tree/master/stf">encointer github</a></p>
<h2><a class="header" href="#tee-runtime" id="tee-runtime">TEE Runtime</a></h2>
<p>Substrate chains wrap all their business logic into a runtime made up of pallets. Integritee does so too, so let's create our TEE runtime:</p>
<pre><code class="language-bash">git clone https://github.com/integritee-network/sgx-runtime.git
</code></pre>
<p>this is actually a fork of node-template, stripped from everything we don't need for our case.</p>
<p>Now we need to include our pallets <em>balances</em> and <em>ceremonies</em> exactly the way you're used to from substrate</p>
<h4><a class="header" href="#runtimesrclibrs" id="runtimesrclibrs">runtime/src/lib.rs</a></h4>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>construct_runtime!(
    pub enum Runtime where
        Block = Block,
        NodeBlock = opaque::Block,
        UncheckedExtrinsic = UncheckedExtrinsic
    {
        System: system::{Module, Call, Config, Storage, Event&lt;T&gt;},
        Timestamp: timestamp::{Module, Call, Storage, Inherent},
        Balances: balances::{Module, Call, Storage, Config&lt;T&gt;, Event&lt;T&gt;},
        TransactionPayment: transaction_payment::{Module, Storage},
        Sudo: sudo::{Module, Call, Config&lt;T&gt;, Storage, Event&lt;T&gt;},
        EncointerCeremonies: encointer_ceremonies::{Module, Call, Storage, Config&lt;T&gt;, Event&lt;T&gt;},
        EncointerBalances: encointer_balances::{Module, Call, Storage, Event&lt;T&gt;},
    }
);
<span class="boring">}
</span></code></pre></pre>
<p>Looks familiar? If not, <a href="https://substrate.dev/docs/en/tutorials/add-a-pallet/import-a-pallet">learn from the best</a></p>
<p>We will skip the nitty gritty of including your pallets.</p>
<h2><a class="header" href="#integritee-node" id="integritee-node">integritee-node</a></h2>
<p>The blockchain we'll be using is based on parity's node-template with one integritee-specific pallet that will take care of the worker registry and will proxy <code>TrustedCalls</code></p>
<pre><code class="language-bash">git clone https://github.com/integritee-network/integritee-node
</code></pre>
<p>Encointer will add its public pallets to this node tempalte: <em>scheduler</em> and <em>currencies</em>. See <a href="https://github.com/encointer/encointer-node/tree/sgx-master">encointer-node</a></p>
<h2><a class="header" href="#integritee-worker" id="integritee-worker">integritee-worker</a></h2>
<p>The integritee-worker is the service running on a Intel SGX enabled machine. It will run our TEE-runtime inside an SGX enclave, operating on encrypted state.</p>
<p>The worker will also be our ChainRelay, a trustless bridge from the blockchain into the SGX enclave.</p>
<p>The worker itself will not need to be modified, it is the framework which runs your custom STF logic. It also offers you a customizable CLI interface</p>
<h2><a class="header" href="#trustedcall" id="trustedcall">TrustedCall</a></h2>
<p>Now we need a way to call our custom pallet functions isolated in a TEE.</p>
<p>Integritee encapsulates all the application-specific stuff in its <code>integritee-stf</code> crate that you can customize.</p>
<pre><code class="language-bash">git clone https://github.com/integritee-network/worker
</code></pre>
<p>Let's start by defining a new <code>TrustedCall</code>:</p>
<h4><a class="header" href="#encointer-workerstfsrclibrs" id="encointer-workerstfsrclibrs">encointer-worker/stf/src/lib.rs</a></h4>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[derive(Encode, Decode, Clone)]
#[allow(non_camel_case_types)]
pub enum TrustedCall {
    balance_transfer(AccountId, AccountId, CurrencyIdentifier, BalanceType),
    ceremonies_register_participant(AccountId, CurrencyIdentifier, Option&lt;ProofOfAttendance&lt;MultiSignature, AccountId32&gt;&gt;)
}

impl TrustedCall {
    fn account(&amp;self) -&gt; &amp;AccountId {
        match self {
            TrustedCall::balance_transfer(account, _, _, _) =&gt; account,
            TrustedCall::ceremonies_register_participant(account, _, _) =&gt; account,
        }
    }
...

<span class="boring">}
</span></code></pre></pre>
<p><strong>Important</strong>: The first argument of each <code>TrustedCall</code> has to be the <em>incognito</em> <code>AccountId</code> which will sign the <code>TrustedCallSigned</code> which will then be encrypted and sent to the worker through the blockchain as a proxy.</p>
<p>Now that we defined a new call we need to execute it:</p>
<h4><a class="header" href="#encointer-workerstfsrcsgxrs" id="encointer-workerstfsrcsgxrs">encointer-worker/stf/src/sgx.rs</a></h4>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    pub fn execute(ext: &amp;mut State, call: TrustedCall, _nonce: u32, calls: &amp;mut Vec&lt;OpaqueCall&gt;) {
        ext.execute_with(|| {
            let _result = match call {
                TrustedCall::balance_transfer(from, to, cid, value) =&gt; {
                    let origin = sgx_runtime::Origin::signed(AccountId32::from(from));
                    sgx_runtime::EncointerBalancesCall::&lt;Runtime&gt;::transfer(AccountId32::from(to), cid, value)
                        .dispatch(origin)
                }
                TrustedCall::ceremonies_register_participant(from, cid, proof) =&gt; {
                    let origin = sgx_runtime::Origin::signed(AccountId32::from(from));
                    sgx_runtime::EncointerCeremoniesCall::&lt;Runtime&gt;::register_participant(cid, proof)
                        .dispatch(origin)
                }
            };
        });
    }
<span class="boring">}
</span></code></pre></pre>
<p>Now you see that <code>TrustedCall::ceremonies_register_participant()</code> calls <code>register_participant()</code> in our <code>ceremonies</code> pallet.</p>
<p>This function call depends on the <code>scheduler</code> and <code>currencies</code> pallets which are not present in our TEE runtime. It is on-chain. So we need to tell Integritee that it needs to fetch on-chain storage (and verify a read-proof) before executing our call:</p>
<h4><a class="header" href="#encointer-workerstfsrcsgxrs-1" id="encointer-workerstfsrcsgxrs-1">encointer-worker/stf/src/sgx.rs</a></h4>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    pub fn get_storage_hashes_to_update(call: &amp;TrustedCall) -&gt; Vec&lt;Vec&lt;u8&gt;&gt; {
        let mut key_hashes = Vec::new();
        match call {
            TrustedCall::balance_transfer(account, _, _, _) =&gt; { },
            TrustedCall::ceremonies_register_participant(account, _, _) =&gt; {
                key_hashes.push(storage_value_key(&quot;EncointerScheduler&quot;, &quot;CurrentPhase&quot;));
                key_hashes.push(storage_value_key(&quot;EncointerScheduler&quot;, &quot;CurrentCeremonyIndex&quot;));
                key_hashes.push(storage_value_key(&quot;EncointerCurrencies&quot;, &quot;CurrencyIdentifiers&quot;));
            }
        };
        key_hashes
    }
<span class="boring">}
</span></code></pre></pre>
<p>See <a href="./howto_access_onchain_storage.html">How to access on-chain storage</a> for more details.</p>
<p><strong>Important</strong>: Make sure your on-chain runtime and TEE runtime depend on the same version of substrate. Otherwise, mapping storage keys between the two runtimes might fail.</p>
<p>Finally, we will extend our CLI client to allow us to call our function:</p>
<h4><a class="header" href="#encointer-workerstfsrcclirs" id="encointer-workerstfsrcclirs">encointer-worker/stf/src/cli.rs</a></h4>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span> ...
         .add_cmd(
            Command::new(&quot;register-participant&quot;)
                .description(&quot;register participant for next encointer ceremony&quot;)
                .options(|app| {
                    app.arg(
                        Arg::with_name(&quot;accountid&quot;)
                            .takes_value(true)
                            .required(true)
                            .value_name(&quot;SS58&quot;)
                            .help(&quot;AccountId in ss58check format&quot;),
                    )
                })
                .runner(move |_args: &amp;str, matches: &amp;ArgMatches&lt;'_&gt;| {
                    let arg_who = matches.value_of(&quot;accountid&quot;).unwrap();
                    let who = get_pair_from_str(matches, arg_who);
                    let (mrenclave, shard) = get_identifiers(matches);
                    let tcall = TrustedCall::ceremonies_register_participant(
                        sr25519_core::Public::from(who.public()),
                        shard, // for encointer we assume that every currency has its own shard. so shard == cid
                        None
                    );
                    let nonce = 0; // FIXME: hard coded for now
                    let tscall =
                        tcall.sign(&amp;sr25519_core::Pair::from(who), nonce, &amp;mrenclave, &amp;shard);
                    println!(
                        &quot;send trusted call register_participant for {}&quot;,
                        tscall.call.account(),
                    );
                    perform_operation(matches, &amp;TrustedOperationSigned::call(tscall));
                    Ok(())
                }),
        )
<span class="boring">}
</span></code></pre></pre>
<p>This will allow us to call</p>
<pre><code class="language-bash"> encointer-client trusted register-participant //AliceIncognito --mrenclave Jtpuqp6iA98JmhUYwhbcV8mvEgF9uFbksWaAeyALZQA --shard 3LjCHdiNbNLKEtwGtBf6qHGZnfKFyjLu9v3uxVgDL35C
</code></pre>
<p>The <code>--mrenclave</code> identifies the <a href="./glossary.html">TCB</a> while <code>--shard</code> identifies the local currency we're registering for.</p>
<h2><a class="header" href="#sharding" id="sharding">Sharding</a></h2>
<p>As you may have guessed by now, Encointer uses sharding. Encointer maintains a global registry of local currencies on-chain (with the <code>currencies</code> pallet). The balances for each local currency are maintained confidentially within Integritee. One shard for each currency. This means that a worker has to decide what shard it operates on.</p>
<p>See <a href="./sharding.html">Sharding</a> for more details.</p>
<h2><a class="header" href="#trustedgetter" id="trustedgetter">TrustedGetter</a></h2>
<p>Now that everything is super-isolated and confidential, how should we know if our call actually worked?</p>
<p>That's why integritee-worker exposes a websocket interface for encrypted and authenticated queries.</p>
<p>We will now implement a getter that can only be called by the <code>AccountId</code> it refers to.</p>
<h4><a class="header" href="#encointer-workerstfsrclibrs-1" id="encointer-workerstfsrclibrs-1">encointer-worker/stf/src/lib.rs</a></h4>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[derive(Encode, Decode, Clone)]
#[allow(non_camel_case_types)]
pub enum TrustedGetter {
    balance(AccountId, CurrencyIdentifier),
    ceremony_registration(AccountId, CurrencyIdentifier)
}

impl TrustedGetter {
    pub fn account(&amp;self) -&gt; &amp;AccountId {
        match self {
            TrustedGetter::balance(account, _) =&gt; account,
            TrustedGetter::ceremony_registration(account, _) =&gt; account,
        }
    }
    ...
<span class="boring">}
</span></code></pre></pre>
<p>Again, the first argument specifies the <code>AccountId</code> that is allowed to read its part of the state, authenticated by a signature.</p>
<h4><a class="header" href="#encointer-workerstfsrcsgxrs-2" id="encointer-workerstfsrcsgxrs-2">encointer-worker/stf/src/sgx.rs</a></h4>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    pub fn get_state(ext: &amp;mut State, getter: TrustedGetter) -&gt; Option&lt;Vec&lt;u8&gt;&gt; {
        ext.execute_with(|| match getter {
            TrustedGetter::balance(who, cid) =&gt; {
                Some(get_encointer_balance(&amp;who, &amp;cid).encode())
            },
            TrustedGetter::ceremony_registration(who, cid) =&gt; {
                Some(get_ceremony_registration(&amp;who, &amp;cid).encode())
            }
        })
    }
    ...

fn get_ceremony_registration(who: &amp;AccountId, cid: &amp;CurrencyIdentifier) -&gt; ParticipantIndexType {
    let cindex = match sp_io::storage::get(&amp;storage_value_key(
        &quot;EncointerScheduler&quot;,
        &quot;CurrentCeremonyIndex&quot;)) {
            Some(val) =&gt; if let Ok(v) = CeremonyIndexType::decode(&amp;mut val.as_slice()) { v } else { 0 },
            None =&gt; 0
    };
    info!(&quot;cindex = {}&quot;, cindex);
    if let Some(res) = sp_io::storage::get(&amp;storage_double_map_key(
        &quot;EncointerCeremonies&quot;,
        &quot;ParticipantIndex&quot;,
        &amp;(cid,cindex),
        &amp;StorageHasher::Blake2_128Concat,
        who,
        &amp;StorageHasher::Blake2_128Concat,
    )) {
        if let Ok(pindex) = ParticipantIndexType::decode(&amp;mut res.as_slice()) {
            pindex
        } else {
            debug!(&quot;can't decode ParticipantIndexType for {:x?}&quot;, res);
            0
        }
    } else {
        debug!(&quot;no registration for caller&quot;);
        0
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><em>Note</em>: Currently, the stf is not aware of the runtime metadata, so we have to hard-code hashers for <code>StorageMap</code> and <code>StorageDoubleMap</code>.</p>
<p>Again, we will introduce our getter in the CLI:</p>
<h4><a class="header" href="#encointer-workerstfsrcclirs-1" id="encointer-workerstfsrcclirs-1">encointer-worker/stf/src/cli.rs</a></h4>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>.add_cmd(
    Command::new(&quot;ceremony-registration&quot;)
        .description(&quot;query state if registration for this ceremony&quot;)
        .options(|app| {
            app.arg(
                Arg::with_name(&quot;accountid&quot;)
                    .takes_value(true)
                    .required(true)
                    .value_name(&quot;SS58&quot;)
                    .help(&quot;AccountId in ss58check format&quot;),
            )
        })
        .runner(move |_args: &amp;str, matches: &amp;ArgMatches&lt;'_&gt;| {
            let arg_who = matches.value_of(&quot;accountid&quot;).unwrap();
            println!(&quot;arg_who = {:?}&quot;, arg_who);
            let who = get_pair_from_str(matches, arg_who);
            let (mrenclave, shard) = get_identifiers(matches);
            let tgetter =
                TrustedGetter::ceremony_registration(sr25519_core::Public::from(who.public()), shard);
            let tsgetter = tgetter.sign(&amp;sr25519_core::Pair::from(who));
            let res = perform_operation(matches, &amp;TrustedOperationSigned::get(tsgetter));
            let ind = if let Some(v) = res {
                if let Ok(vd) = ParticipantIndexType::decode(&amp;mut v.as_slice()) {
                    vd
                } else {
                    info!(&quot;could not decode value {:x?}&quot;, v);
                    0
                }
            } else {
                0
            };
            println!(&quot;{}&quot;, ind);
            Ok(())
        }),
)
<span class="boring">}
</span></code></pre></pre>
<p>So we can query our index in the particpant registry with our CLI</p>
<pre><code class="language-bash">encointer-client trusted ceremony-registration //AliceIncognito --mrenclave Jtpuqp6iA98JmhUYwhbcV8mvEgF9uFbksWaAeyALZQA --shard 3LjCHdiNbNLKEtwGtBf6qHGZnfKFyjLu9v3uxVgDL35C
</code></pre>
<p>Happy coding!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="howto_access_onchain_storage.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="roadmap.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="howto_access_onchain_storage.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="roadmap.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
